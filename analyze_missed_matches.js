/**
 * KA√áIRILAN E≈ûLE≈ûMELER ANALƒ∞Z ARACI
 * 
 * API'nin ka√ßƒ±rdƒ±ƒüƒ± ama manuel hesaplamanƒ±n bulduƒüu dosyalarƒ± detaylƒ± analiz eder
 */

const fs = require('fs');
const path = require('path');
const axios = require('axios');

class MissedMatchAnalyzer {
    constructor() {
        this.apiUrl = 'http://localhost:50001';
        this.musicDatabase = null;
    }

    async loadDatabase() {
        if (this.musicDatabase) return this.musicDatabase;
        
        try {
            const dbPath = '/Users/koray/projects/PlaylistOrganizer-py/musicfiles.db.json';
            const dbData = JSON.parse(fs.readFileSync(dbPath, 'utf8'));
            this.musicDatabase = dbData;
            console.log(`üìä Veritabanƒ± y√ºklendi: ${dbData.musicFiles.length} dosya`);
            return dbData;
        } catch (error) {
            console.error('‚ùå Veritabanƒ± y√ºkleme hatasƒ±:', error.message);
            return null;
        }
    }

    /**
     * Kelime √ßƒ±karma - server.js ile aynƒ±
     */
    extractWords(fileName, filePath) {
        const CHAR_MAP = {
            "ƒü": "g", "ƒû": "G", "ƒ±": "i", "I": "I", "ƒ∞": "I", "≈ü": "s", "≈û": "S",
            "√ß": "c", "√á": "C", "√º": "u", "√ú": "U", "√∂": "o", "√ñ": "O"
        };
        
        function normalizeText(text) {
            let normalized = text.normalize("NFKC");
            normalized = normalized.split('').map(c => CHAR_MAP[c] || c).join('');
            normalized = normalized.toLowerCase();
            normalized = normalized.replace(/[^a-zA-Z0-9\s]/g, '');
            normalized = normalized.replace(/\s+/g, ' ');
            return normalized.trim();
        }
        
        // Klas√∂r kelimeleri
        const pathParts = path.dirname(filePath).split(path.sep).filter(p => p && p !== "." && !p.startsWith("/"));
        const folderWords = [];
        for (const folder of pathParts) {
            const normalizedFolder = normalizeText(folder);
            folderWords.push(...normalizedFolder.split(/\s+/).filter(w => w.length > 1));
        }
        
        // Dosya kelimeleri (parantez temizleme ile)
        const fileNameWithoutExt = path.parse(fileName).name;
        const cleanedFileName = fileNameWithoutExt
            .replace(/\([^)]*\)/g, '')
            .replace(/\[[^\]]*\]/g, '')
            .replace(/\{[^}]*\}/g, '')
            .replace(/\s+/g, ' ')
            .trim();
        
        const fileNameParts = cleanedFileName.split(/[-_\s]+/).filter(part => part.length > 0);
        const fileWords = [];
        for (const part of fileNameParts) {
            const normalizedPart = normalizeText(part);
            fileWords.push(...normalizedPart.split(/\s+/).filter(w => w.length > 1));
        }
        
        return {
            folder_words: folderWords,
            file_words: fileWords,
            parentheses_words: [], // Basit versiyon
            all_words: [...folderWords, ...fileWords]
        };
    }

    /**
     * Manuel benzerlik hesaplama
     */
    calculateManualSimilarity(searchWords, targetWords) {
        const searchFile = searchWords.file_words;
        const targetFile = targetWords.file_words;
        
        if (searchFile.length === 0 || targetFile.length === 0) {
            return 0.0;
        }
        
        // Exact match
        let exactMatches = 0;
        for (const searchWord of searchFile) {
            if (targetFile.includes(searchWord)) {
                exactMatches++;
            }
        }
        const exactScore = exactMatches / searchFile.length;
        
        // Fuzzy match
        let fuzzyScore = 0;
        let comparisons = 0;
        for (const searchWord of searchFile) {
            let bestSimilarity = 0;
            for (const targetWord of targetFile) {
                if (targetWord.includes(searchWord) && searchWord.length >= 3) {
                    bestSimilarity = Math.max(bestSimilarity, 0.8);
                }
                if (searchWord.includes(targetWord) && targetWord.length >= 3) {
                    bestSimilarity = Math.max(bestSimilarity, 0.7);
                }
            }
            if (bestSimilarity > 0) {
                fuzzyScore += bestSimilarity;
                comparisons++;
            }
        }
        fuzzyScore = comparisons > 0 ? fuzzyScore / comparisons : 0.0;
        
        // Context match
        const searchFolder = searchWords.folder_words;
        const targetFolder = targetWords.folder_words;
        let contextScore = 0.0;
        if (searchFolder.length > 0 && targetFolder.length > 0) {
            let exactFolderMatches = 0;
            for (const searchWord of searchFolder) {
                if (targetFolder.includes(searchWord)) {
                    exactFolderMatches++;
                }
            }
            contextScore = exactFolderMatches / Math.max(searchFolder.length, targetFolder.length);
        }
        
        // Final score
        const baseScore = (exactScore * 0.35) + (fuzzyScore * 0.2) + (contextScore * 0.15) + (0.1 * 0.1) + (0.0 * 0.2);
        return Math.max(0.0, Math.min(1.0, baseScore));
    }

    /**
     * Ka√ßƒ±rƒ±lan dosyayƒ± detaylƒ± analiz et
     */
    async analyzeMissedFile(searchPath, manualBestPath) {
        console.log(`\nüîç DETAYLI ANALƒ∞Z: ${path.basename(searchPath)}`);
        console.log('='.repeat(60));

        // 1. Kelime analizi
        const searchFileName = path.basename(searchPath);
        const manualFileName = path.basename(manualBestPath);
        
        const searchWords = this.extractWords(searchFileName, searchPath);
        const manualWords = this.extractWords(manualFileName, manualBestPath);
        
        console.log(`üìù ARAMA DOSYASI: ${searchFileName}`);
        console.log(`   Klas√∂r kelimeleri: [${searchWords.folder_words.join(', ')}]`);
        console.log(`   Dosya kelimeleri: [${searchWords.file_words.join(', ')}]`);
        
        console.log(`\nüìù MANUEL EN ƒ∞Yƒ∞: ${manualFileName}`);
        console.log(`   Klas√∂r kelimeleri: [${manualWords.folder_words.join(', ')}]`);
        console.log(`   Dosya kelimeleri: [${manualWords.file_words.join(', ')}]`);

        // 2. Veritabanƒ±ndan ger√ßek dosyayƒ± bul
        const db = await this.loadDatabase();
        const manualFile = db.musicFiles.find(f => f.path === manualBestPath);
        
        if (manualFile) {
            console.log(`\nüìù VERƒ∞TABANINDAKƒ∞ GER√áEK VERƒ∞:`);
            console.log(`   Normalize isim: "${manualFile.normalizedName}"`);
            console.log(`   Klas√∂r kelimeleri: [${manualFile.folderWords.join(', ')}]`);
            console.log(`   Dosya kelimeleri: [${manualFile.fileWords.join(', ')}]`);
            console.log(`   Parantez kelimeleri: [${(manualFile.parenthesesWords || []).join(', ')}]`);
        }

        // 3. API'nin bulduƒüu sonucu al
        try {
            const response = await axios.post(`${this.apiUrl}/api/search/files`, {
                paths: [searchPath],
                options: { limit: 10, threshold: 0.01 }
            });

            if (response.data.status === 'success' && response.data.data[0]) {
                const apiResult = response.data.data[0];
                const apiMatches = apiResult.matches || [];
                
                console.log(`\nüìä API SONU√áLARI:`);
                apiMatches.slice(0, 5).forEach((match, index) => {
                    const isManualBest = match.path === manualBestPath;
                    const marker = isManualBest ? 'üéØ' : '  ';
                    console.log(`   ${marker} ${index + 1}. ${match.similarity.toFixed(4)} - ${path.basename(match.path)}`);
                    
                    if (isManualBest) {
                        console.log(`      üëÜ Bu manuel en iyi e≈üle≈üme! Sƒ±ralama: ${index + 1}`);
                    }
                });

                // Manuel en iyi dosya API sonu√ßlarƒ±nda var mƒ±?
                const manualInAPI = apiMatches.find(m => m.path === manualBestPath);
                if (manualInAPI) {
                    const rank = apiMatches.findIndex(m => m.path === manualBestPath) + 1;
                    console.log(`\n‚úÖ Manuel en iyi dosya API'de ${rank}. sƒ±rada (${manualInAPI.similarity.toFixed(4)})`);
                    console.log(`‚ùå SORUN: SIRALAMA ALGORƒ∞TMASI - daha iyi dosya a≈üaƒüƒ±da kaldƒ±`);
                } else {
                    console.log(`\n‚ùå Manuel en iyi dosya API sonu√ßlarƒ±nda YOK!`);
                    console.log(`‚ùå SORUN: BENZERLƒ∞K ALGORƒ∞TMASI - dosya threshold'u ge√ßemiyor`);
                }
            }
        } catch (error) {
            console.error('‚ùå API analiz hatasƒ±:', error.message);
        }

        // 4. Kelime e≈üle≈üme analizi
        if (manualFile) {
            console.log(`\nüî§ KELƒ∞ME E≈ûLE≈ûME ANALƒ∞Zƒ∞:`);
            
            const searchFileWords = searchWords.file_words;
            const targetFileWords = manualFile.fileWords;
            
            console.log(`   Arama kelimeleri: [${searchFileWords.join(', ')}]`);
            console.log(`   Hedef kelimeleri: [${targetFileWords.join(', ')}]`);
            
            // Exact matches
            const exactMatches = searchFileWords.filter(sw => targetFileWords.includes(sw));
            console.log(`   Exact e≈üle≈ümeler: [${exactMatches.join(', ')}] (${exactMatches.length}/${searchFileWords.length})`);
            
            // Partial matches
            const partialMatches = [];
            searchFileWords.forEach(sw => {
                targetFileWords.forEach(tw => {
                    if (tw.includes(sw) && sw.length >= 3) {
                        partialMatches.push(`${sw}‚Üí${tw}`);
                    }
                    if (sw.includes(tw) && tw.length >= 3) {
                        partialMatches.push(`${sw}‚äÉ${tw}`);
                    }
                });
            });
            console.log(`   Partial e≈üle≈ümeler: [${partialMatches.join(', ')}]`);
            
            // Klas√∂r e≈üle≈ümeleri
            const folderMatches = searchWords.folder_words.filter(fw => manualFile.folderWords.includes(fw));
            console.log(`   Klas√∂r e≈üle≈ümeleri: [${folderMatches.join(', ')}] (${folderMatches.length}/${searchWords.folder_words.length})`);
        }
    }

    /**
     * T√ºm ka√ßƒ±rƒ±lan dosyalarƒ± analiz et
     */
    async analyzeAllMissedFiles() {
        console.log('üîç KA√áIRILAN DOSYALAR ANALƒ∞Zƒ∞');
        console.log('='.repeat(50));

        // Test verilerini hazƒ±rla
        const missedCases = [
            {
                search: "/Users/koray/Documents/VirtualDJ/Cache/CloudDrive/Filatov, Karas, Sharapov - Au Au (Vincent & Diaz Mashup) (2).mp3",
                manualBest: "Filatov, Karas, Sharapov - Au Au (Vincent & Diaz Mashup).mp3"
            },
            {
                search: "/Users/koray/Documents/VirtualDJ/Cache/CloudDrive/Peter Piper(Run DMC)It Takes Two(Rod Base) Sample Endii track (6).m4a", 
                manualBest: "Peter Piper(Run DMC)It Takes Two(Rod Base) Sample Endii track.m4a"
            },
            {
                search: "/Users/koray/Documents/VirtualDJ/Cache/CloudDrive/6IX9INE- PUNANI (Official Music Video) (3).m4a",
                manualBest: "6IX9INE- PUNANI (Official Music Video).m4a"
            },
            {
                search: "/Users/koray/Music/KorayMusics/Video/Bodrum Ak≈üamlarƒ± (Club Remix).mp4",
                manualBest: "B√ºlent Sertta≈ü - Bodrum Ak≈üamlarƒ± (Official Audio Music).m4a"
            }
        ];

        // Manuel en iyi dosyalarƒ± veritabanƒ±nda bul
        const db = await this.loadDatabase();
        const realMissedCases = [];

        for (const testCase of missedCases) {
            // Manuel en iyi dosyayƒ± veritabanƒ±nda ara
            const manualFile = db.musicFiles.find(f => 
                f.path.includes(testCase.manualBest) || 
                path.basename(f.path) === testCase.manualBest
            );
            
            if (manualFile) {
                realMissedCases.push({
                    ...testCase,
                    manualBestPath: manualFile.path
                });
            } else {
                console.log(`‚ö†Ô∏è Manuel en iyi dosya veritabanƒ±nda bulunamadƒ±: ${testCase.manualBest}`);
            }
        }

        // Her birini detaylƒ± analiz et
        for (const testCase of realMissedCases) {
            await this.analyzeMissedFile(testCase.search, testCase.manualBestPath);
            console.log('\n' + '='.repeat(60));
        }

        // Genel analiz ve √∂neriler
        this.generateImprovementSuggestions(realMissedCases);
    }

    /**
     * ƒ∞yile≈ütirme √∂nerileri olu≈ütur
     */
    generateImprovementSuggestions(missedCases) {
        console.log('\nüí° ƒ∞Yƒ∞LE≈ûTƒ∞RME √ñNERƒ∞LERƒ∞');
        console.log('='.repeat(40));

        console.log('\nüîç SORUN ANALƒ∞Zƒ∞:');
        console.log('1. Parantez i√ßerik sorunu: "(2)", "(3)" gibi sayƒ±lar farklƒ±lƒ±k yaratƒ±yor');
        console.log('2. Sƒ±ralama algoritmasƒ±: Daha iyi e≈üle≈ümeler a≈üaƒüƒ±da kalƒ±yor');
        console.log('3. Context matching: Klas√∂r benzerliƒüi yanlƒ±≈ü aƒüƒ±rlƒ±klandƒ±rƒ±lƒ±yor olabilir');

        console.log('\nüîß √ñNERƒ∞LEN √á√ñZ√úMLER:');
        
        console.log('\n1Ô∏è‚É£ PARANTEZ ƒ∞√áƒ∞ SAYI NORMALIZASYONU:');
        console.log('```javascript');
        console.log('// Parantez i√ßindeki sayƒ±larƒ± ignore et');
        console.log('function cleanParenthesesNumbers(text) {');
        console.log('    return text.replace(/\\(\\d+\\)/g, "").trim();');
        console.log('}');
        console.log('```');

        console.log('\n2Ô∏è‚É£ SKOR HESAPLAMA ƒ∞Yƒ∞LE≈ûTƒ∞RMESƒ∞:');
        console.log('```javascript');
        console.log('// Exact match aƒüƒ±rlƒ±ƒüƒ±nƒ± artƒ±r');
        console.log('const baseScore = (exactScore * 0.5) + (fuzzyScore * 0.2) + ');
        console.log('                  (contextScore * 0.1) + (specialScore * 0.1) + ');
        console.log('                  (parenthesesScore * 0.1);');
        console.log('```');

        console.log('\n3Ô∏è‚É£ THRESHOLD OPTƒ∞Mƒ∞ZASYONU:');
        console.log('```javascript');
        console.log('// Dinamik threshold - kelime sayƒ±sƒ±na g√∂re');
        console.log('const threshold = searchWords.file_words.length === 1 ? 0.2 : 0.1;');
        console.log('```');

        console.log('\n4Ô∏è‚É£ FUZZY MATCHING ƒ∞Yƒ∞LE≈ûTƒ∞RMESƒ∞:');
        console.log('```javascript');
        console.log('// Levenshtein distance threshold\'unu d√º≈ü√ºr');
        console.log('if (similarity > 0.5) { // 0.6\'dan 0.5\'e');
        console.log('    bestSimilarity = Math.max(bestSimilarity, similarity);');
        console.log('}');
        console.log('```');

        console.log('\nüéØ √ñNCELƒ∞K SIRASI:');
        console.log('1. üî¥ Y√úKSEK: Parantez i√ßi sayƒ± normalizasyonu');
        console.log('2. üü° ORTA: Exact match aƒüƒ±rlƒ±ƒüƒ±nƒ± artƒ±r');
        console.log('3. üü¢ D√ú≈û√úK: Fuzzy matching threshold');
    }

    /**
     * Belirli bir dosya i√ßin detaylƒ± analiz
     */
    async analyzeSpecificFile(searchPath) {
        console.log(`üéØ √ñZEL DOSYA ANALƒ∞Zƒ∞: ${path.basename(searchPath)}`);
        console.log('='.repeat(50));

        // API sonucunu al
        try {
            const response = await axios.post(`${this.apiUrl}/api/search/files`, {
                paths: [searchPath],
                options: { limit: 10, threshold: 0.01 }
            });

            const apiResult = response.data.data[0];
            const apiMatches = apiResult.matches || [];

            console.log(`\nüìä API BULDUƒûU ƒ∞LK 5 SONU√á:`);
            apiMatches.slice(0, 5).forEach((match, index) => {
                console.log(`   ${index + 1}. ${match.similarity.toFixed(4)} - ${path.basename(match.path)}`);
            });

            // Manuel en iyi 5'i bul
            const db = await this.loadDatabase();
            const searchWords = this.extractWords(path.basename(searchPath), searchPath);
            
            const manualResults = [];
            for (const file of db.musicFiles) {
                const targetWords = {
                    folder_words: file.folderWords,
                    file_words: file.fileWords,
                    parentheses_words: file.parenthesesWords || []
                };
                
                const similarity = this.calculateManualSimilarity(searchWords, targetWords);
                if (similarity > 0.01) {
                    manualResults.push({
                        path: file.path,
                        similarity: similarity,
                        file: file
                    });
                }
            }

            manualResults.sort((a, b) => b.similarity - a.similarity);

            console.log(`\nüìä MANUEL HESAPLAMA ƒ∞LK 5 SONU√á:`);
            manualResults.slice(0, 5).forEach((match, index) => {
                const inAPI = apiMatches.find(a => a.path === match.path);
                const apiRank = inAPI ? apiMatches.findIndex(a => a.path === match.path) + 1 : 'YOK';
                console.log(`   ${index + 1}. ${match.similarity.toFixed(4)} - ${path.basename(match.path)} (API: ${apiRank})`);
            });

            // Kar≈üƒ±la≈ütƒ±rma
            console.log(`\nüîÑ KAR≈ûILA≈ûTIRMA:`);
            const apiTop = apiMatches[0];
            const manualTop = manualResults[0];
            
            if (apiTop && manualTop) {
                console.log(`   API En ƒ∞yi: ${apiTop.similarity.toFixed(4)} - ${path.basename(apiTop.path)}`);
                console.log(`   Manuel En ƒ∞yi: ${manualTop.similarity.toFixed(4)} - ${path.basename(manualTop.path)}`);
                console.log(`   Fark: ${(apiTop.similarity - manualTop.similarity).toFixed(4)}`);
                
                if (apiTop.path === manualTop.path) {
                    console.log(`   ‚úÖ Aynƒ± dosya - algoritma optimal`);
                } else {
                    console.log(`   ‚ùå Farklƒ± dosyalar - algoritma iyile≈ütirilebilir`);
                }
            }

        } catch (error) {
            console.error('‚ùå API analiz hatasƒ±:', error.message);
        }
    }
}

// CLI kullanƒ±mƒ±
if (require.main === module) {
    const analyzer = new MissedMatchAnalyzer();
    
    const command = process.argv[2];
    const filePath = process.argv[3];
    
    async function main() {
        try {
            if (command === 'all') {
                await analyzer.analyzeAllMissedFiles();
            } else if (command === 'file' && filePath) {
                await analyzer.analyzeSpecificFile(filePath);
            } else {
                console.log('üîß KA√áIRILAN E≈ûLE≈ûMELER ANALƒ∞Z ARACI');
                console.log('='.repeat(40));
                console.log('Kullanƒ±m:');
                console.log('  node analyze_missed_matches.js all                    # T√ºm ka√ßƒ±rƒ±lan dosyalarƒ± analiz et');
                console.log('  node analyze_missed_matches.js file <dosya_yolu>     # Belirli dosyayƒ± analiz et');
                console.log('\n√ñrnekler:');
                console.log('  node analyze_missed_matches.js all');
                console.log('  node analyze_missed_matches.js file "/path/to/file.mp3"');
            }
        } catch (error) {
            console.error('‚ùå Fatal error:', error);
        }
    }
    
    main();
}

module.exports = MissedMatchAnalyzer;

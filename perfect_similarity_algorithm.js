/**
 * M√úKEMMEL BENZERLƒ∞K ALGORƒ∞TMASI
 * 
 * Global-missing ve musicfiles.db.json analizi sonucu geli≈ütirildi
 * Test sonu√ßlarƒ±: %61.3 ba≈üarƒ±sƒ±zlƒ±k ‚Üí %95+ ba≈üarƒ± hedefi
 */

const path = require('path');
const fs = require('fs');

class PerfectSimilarityAlgorithm {
    constructor() {
        this.musicDatabase = null;
        this.performanceStats = {
            totalSearches: 0,
            exactMatches: 0,
            fuzzyMatches: 0,
            contextMatches: 0,
            parenthesesMatches: 0,
            remixPenalties: 0
        };
    }

    async loadDatabase() {
        if (this.musicDatabase) return this.musicDatabase;
        
        try {
            const dbPath = '/Users/koray/projects/PlaylistOrganizer-py/musicfiles.db.json';
            const dbData = JSON.parse(fs.readFileSync(dbPath, 'utf8'));
            this.musicDatabase = dbData;
            console.log(`üìä Veritabanƒ± y√ºklendi: ${dbData.musicFiles.length} dosya`);
            return dbData;
        } catch (error) {
            console.error('‚ùå Veritabanƒ± y√ºkleme hatasƒ±:', error.message);
            return null;
        }
    }

    /**
     * GELƒ∞≈ûMƒ∞≈û KARAKTER NORMALƒ∞ZASYONU
     * T√ºrk√ße karakterler + uluslararasƒ± karakterler
     */
    normalizeText(text, options = {}) {
        const ENHANCED_CHAR_MAP = {
            // T√ºrk√ße karakterler
            "ƒü": "g", "ƒû": "G", "ƒ±": "i", "I": "I", "ƒ∞": "I", "≈ü": "s", "≈û": "S",
            "√ß": "c", "√á": "C", "√º": "u", "√ú": "U", "√∂": "o", "√ñ": "O",
            
            // Uluslararasƒ± karakterler
            "√†": "a", "√°": "a", "√¢": "a", "√£": "a", "√§": "a", "√•": "a", "√¶": "ae",
            "√®": "e", "√©": "e", "√™": "e", "√´": "e", "√¨": "i", "√≠": "i", "√Æ": "i", "√Ø": "i",
            "√≤": "o", "√≥": "o", "√¥": "o", "√µ": "o", "√∏": "o", "√π": "u", "√∫": "u", "√ª": "u",
            "√Ω": "y", "√æ": "th", "√ø": "y", "√ü": "ss", "√∞": "d", "√±": "n",
            
            // Rus√ßa karakterler
            "–∞": "a", "–±": "b", "–≤": "v", "–≥": "g", "–¥": "d", "–µ": "e", "—ë": "e", "–∂": "zh",
            "–∑": "z", "–∏": "i", "–π": "y", "–∫": "k", "–ª": "l", "–º": "m", "–Ω": "n", "–æ": "o",
            "–ø": "p", "—Ä": "r", "—Å": "s", "—Ç": "t", "—É": "u", "—Ñ": "f", "—Ö": "h", "—Ü": "ts",
            "—á": "ch", "—à": "sh", "—â": "sch", "—ä": "", "—ã": "y", "—å": "", "—ç": "e", "—é": "yu", "—è": "ya",
            
            // Arap√ßa karakterler
            "ÿß": "a", "ÿ®": "b", "ÿ™": "t", "ÿ´": "th", "ÿ¨": "j", "ÿ≠": "h", "ÿÆ": "kh", "ÿØ": "d",
            "ÿ∞": "dh", "ÿ±": "r", "ÿ≤": "z", "ÿ≥": "s", "ÿ¥": "sh", "ÿµ": "s", "ÿ∂": "d", "ÿ∑": "t",
            "ÿ∏": "z", "ÿπ": "a", "ÿ∫": "gh", "ŸÅ": "f", "ŸÇ": "q", "ŸÉ": "k", "ŸÑ": "l", "ŸÖ": "m",
            "ŸÜ": "n", "Ÿá": "h", "Ÿà": "w", "Ÿä": "y"
        };

        if (typeof text !== 'string') return '';

        const keepSpaces = options.keepSpaces !== false;
        const keepSpecialChars = options.keepSpecialChars || false;
        const keepCase = options.keepCase || false;

        let normalized = text;

        // NFKC normalizasyonu ve karakter d√∂n√º≈ü√ºm√º
        normalized = normalized.normalize("NFKC");
        normalized = normalized.split('').map(c => ENHANCED_CHAR_MAP[c] || c).join('');

        if (!keepCase) {
            normalized = normalized.toLowerCase();
        }

        if (!keepSpecialChars) {
            // Sadece alfanumerik ve bo≈üluk karakterlerini koru
            normalized = normalized.replace(/[^a-zA-Z0-9\s]/g, '');
        }

        // √áoklu bo≈üluklarƒ± tek bo≈üluƒüa √ßevir
        normalized = normalized.replace(/\s+/g, ' ');
        return normalized.trim();
    }

    /**
     * GELƒ∞≈ûMƒ∞≈û PARANTEZ Fƒ∞LTRELEME
     * Test sonu√ßlarƒ±na g√∂re parantez kelimeleri √ßok kritik
     */
    advancedParenthesesFilter(text) {
        // Ana metni parantezlerden temizle
        const mainText = text
            .replace(/\([^)]*\)/g, '')
            .replace(/\[[^\]]*\]/g, '')
            .replace(/\{[^}]*\}/g, '')
            .replace(/\s+/g, ' ')
            .trim();
        
        // T√ºm parantez t√ºrlerini yakala
        const parenthesesMatches = text.match(/\([^)]*\)/g) || [];
        const bracketMatches = text.match(/\[[^\]]*\]/g) || [];
        const braceMatches = text.match(/\{[^}]*\}/g) || [];
        
        const allMatches = [...parenthesesMatches, ...bracketMatches, ...braceMatches];
        
        const importantParenthesesWords = [];
        const noiseWords = [
            // Genel g√ºr√ºlt√º kelimeleri
            'official', 'audio', 'video', 'music', 'hd', 'stereo', 'mono',
            'remaster', 'remastered', 'enhanced', 'deluxe', 'high', 'quality',
            'feat', 'featuring', 'ft', 'with', 'vs', 'and', 've', 'ile',
            'youtube', 'spotify', 'apple', 'lyric', 'lyrics', 'karaoke',
            'resmi', 'muzik', 'sarki', 'klip', 'canli', 'performans',
            
            // T√ºrk√ße g√ºr√ºlt√º kelimeleri
            'klip', 'muzik', 'sarki', 'resmi', 'video', 'audio', 'hd',
            'stereo', 'mono', 'remaster', 'remastered', 'enhanced',
            
            // Sadece genel remix kelimeleri - √∂zel remix kelimeleri korunacak
            'version', 'edit', 'mix', 'bootleg', 'mashup',
            'extended', 'radio', 'club', 'dub', 'instrumental'
            // 'remix' kaldƒ±rƒ±ldƒ± - artƒ±k √∂zel remix kelimeleri korunacak
        ];
        
        allMatches.forEach(match => {
            const content = match.replace(/[\(\)\[\]\{\}]/g, '');
            const words = content.split(/[\s\-_,&]+/).filter(w => w.length > 1);
            
            words.forEach(word => {
                const normalizedWord = this.normalizeText(word, { keepSpaces: false });
                
                const isNoise = noiseWords.includes(normalizedWord);
                const isNumber = /^\d{1,4}$/.test(normalizedWord);
                const isShort = normalizedWord.length < 3;
                
                // Sayƒ±larƒ± da parantez kelimesi olarak kabul et (2012, 4 gibi)
                if (!isNoise && !isShort) {
                    importantParenthesesWords.push(normalizedWord);
                }
            });
        });
        
        return {
            mainText: mainText,
            parenthesesWords: importantParenthesesWords,
            hybridText: mainText + (importantParenthesesWords.length > 0 ? ' ' + importantParenthesesWords.join(' ') : '')
        };
    }

    /**
     * M√úKEMMEL KELƒ∞ME √áIKARMA
     * Test sonu√ßlarƒ±na g√∂re optimize edildi
     */
    extractPerfectWords(fileName, filePath = "") {
        const pathParts = path.dirname(filePath).split(path.sep).filter(p => p && p !== "." && !p.startsWith("/"));
        const relevantFolders = pathParts;
        
        const fileNameWithoutExt = path.parse(fileName).name;
        
        // PARANTEZ ƒ∞√áƒ∞ SAYI NORMALIZASYONU - kaldƒ±rƒ±ldƒ±, sayƒ±lar da parantez kelimesi olacak
        const cleanedNameForParentheses = fileNameWithoutExt;
        
        // GELƒ∞≈ûMƒ∞≈û PARANTEZ Sƒ∞STEMƒ∞
        const advancedFiltered = this.advancedParenthesesFilter(cleanedNameForParentheses);
        const cleanedFileName = advancedFiltered.mainText;
        
        // Kelime ayƒ±rma - daha agresif
        const fileNameParts = cleanedFileName.split(/[-_\s\.\,\&\+\|\~\!\@\#\$\%\^\*\(\)\[\]\{\}]+/)
            .map(part => part.trim())
            .filter(part => part.length > 0);
        
        // Klas√∂r kelimelerini normalize et
        const folderWords = [];
        for (const folder of relevantFolders) {
            const normalizedFolder = this.normalizeText(folder, { keepSpaces: false });
            const camelCaseWords = normalizedFolder.replace(/([a-z])([A-Z])/g, '$1 $2');
            folderWords.push(...camelCaseWords.split(/\s+/).filter(w => w.length > 1));
        }
        
        // Dosya adƒ± kelimelerini normalize et
        const fileWords = [];
        for (const part of fileNameParts) {
            if (part.trim()) {
                const normalizedPart = this.normalizeText(part, { keepSpaces: false });
                const words = normalizedPart.split(/\s+/).filter(w => w.length > 1);
                fileWords.push(...words);
            }
        }
        
        // Parantez kelimeleri - √ßok kritik!
        const parenthesesWords = advancedFiltered.parenthesesWords;
        
        return {
            'folder_words': folderWords,
            'file_words': fileWords,
            'parentheses_words': parenthesesWords,
            'all_words': [...folderWords, ...fileWords, ...parenthesesWords]
        };
    }

    /**
     * EXACT MATCH HESAPLAMA - Geli≈ütirilmi≈ü
     * Test sonu√ßlarƒ±na g√∂re en kritik fakt√∂r
     */
    calculateExactMatch(searchWords, targetWords) {
        const searchFile = searchWords['file_words'];
        const targetFile = targetWords['file_words'];
        
        if (searchFile.length === 0 || targetFile.length === 0) {
            return 0.0;
        }
        
        let exactMatches = 0;
        let sequenceBonus = 0;
        let positionBonus = 0;
        
        // 1. Tam kelime e≈üle≈ümeleri - TEKRARLANAN KELƒ∞MELER ƒ∞√áƒ∞N √ñZEL BONUS
        const searchWordCounts = {};
        const targetWordCounts = {};
        
        // Arama kelimelerini say
        for (const word of searchFile) {
            searchWordCounts[word] = (searchWordCounts[word] || 0) + 1;
        }
        
        // Hedef kelimelerini say
        for (const word of targetFile) {
            targetWordCounts[word] = (targetWordCounts[word] || 0) + 1;
        }
        
        // E≈üle≈ümeleri hesapla - tekrarlanan kelimeler i√ßin √∂zel bonus
        for (const [word, searchCount] of Object.entries(searchWordCounts)) {
            if (targetWordCounts[word]) {
                const targetCount = targetWordCounts[word];
                const matchedCount = Math.min(searchCount, targetCount);
                exactMatches += matchedCount;
                
                // Tekrarlanan kelime bonusu - "sari sari" gibi
                if (matchedCount > 1) {
                    exactMatches += (matchedCount - 1) * 0.5; // %50 bonus
                }
            }
        }
        
        // 2. Kelime sƒ±rasƒ± bonusu - ardƒ±≈üƒ±k e≈üle≈ümeler
        for (let i = 0; i < searchFile.length - 1; i++) {
            const currentWord = searchFile[i];
            const nextWord = searchFile[i + 1];
            
            const currentIndex = targetFile.indexOf(currentWord);
            const nextIndex = targetFile.indexOf(nextWord);
            
            if (currentIndex !== -1 && nextIndex !== -1 && nextIndex === currentIndex + 1) {
                sequenceBonus += 0.3; // Artƒ±rƒ±ldƒ±
            }
        }
        
        // 3. Tam sƒ±ra e≈üle≈ümesi bonusu
        let fullSequenceBonus = 0;
        if (searchFile.length >= 2 && targetFile.length >= searchFile.length) {
            let isFullSequence = true;
            let lastIndex = -1;
            
            for (const searchWord of searchFile) {
                const index = targetFile.indexOf(searchWord);
                if (index === -1 || index <= lastIndex) {
                    isFullSequence = false;
                    break;
                }
                lastIndex = index;
            }
            
            if (isFullSequence) {
                fullSequenceBonus = 0.4; // Artƒ±rƒ±ldƒ±
            }
        }
        
        // 4. Pozisyon bonusu - ba≈üta e≈üle≈üme daha deƒüerli
        for (let i = 0; i < Math.min(searchFile.length, 3); i++) {
            const searchWord = searchFile[i];
            const targetIndex = targetFile.indexOf(searchWord);
            if (targetIndex === i) {
                positionBonus += 0.2;
            }
        }
        
        const baseScore = exactMatches / searchFile.length;
        const totalScore = baseScore + sequenceBonus + fullSequenceBonus + positionBonus;
        
        // 1.0'ƒ± ge√ßen skorlar √∂zel bonus - "Sarƒ± Sarƒ±" gibi tam e≈üle≈ümeler i√ßin
        if (totalScore > 1.0) {
            return totalScore; // 1.0'ƒ± ge√ßen skorlarƒ± koru
        }
        
        return Math.min(1.0, totalScore);
    }

    /**
     * FUZZY MATCH HESAPLAMA - Geli≈ütirilmi≈ü
     */
    calculateFuzzyMatch(searchWords, targetWords) {
        const searchFile = searchWords['file_words'];
        const targetFile = targetWords['file_words'];
        
        if (searchFile.length === 0 || targetFile.length === 0) {
            return 0.0;
        }
        
        let totalSimilarity = 0;
        let comparisons = 0;
        
        for (const searchWord of searchFile) {
            let bestSimilarity = 0;
            
            for (const targetWord of targetFile) {
                // Substring kontrol√º - geli≈ütirilmi≈ü
                if (targetWord.includes(searchWord) && searchWord.length >= 3) {
                    const ratio = searchWord.length / targetWord.length;
                    bestSimilarity = Math.max(bestSimilarity, 0.7 + (ratio * 0.2));
                }
                
                if (searchWord.includes(targetWord) && targetWord.length >= 3) {
                    const ratio = targetWord.length / searchWord.length;
                    bestSimilarity = Math.max(bestSimilarity, 0.6 + (ratio * 0.2));
                }
                
                // Levenshtein benzerliƒüi - basit versiyon
                if (searchWord.length >= 3 && targetWord.length >= 3) {
                    const distance = this.levenshteinDistance(searchWord, targetWord);
                    const maxLen = Math.max(searchWord.length, targetWord.length);
                    const similarity = 1 - (distance / maxLen);
                    
                    if (similarity > 0.6) {
                        bestSimilarity = Math.max(bestSimilarity, similarity);
                    }
                }
            }
            
            if (bestSimilarity > 0) {
                totalSimilarity += bestSimilarity;
                comparisons++;
            }
        }
        
        return comparisons > 0 ? totalSimilarity / comparisons : 0.0;
    }

    /**
     * CONTEXT MATCH HESAPLAMA - Geli≈ütirilmi≈ü
     */
    calculateContextMatch(searchWords, targetWords) {
        const searchFolder = searchWords['folder_words'];
        const targetFolder = targetWords['folder_words'];
        
        if (searchFolder.length === 0 || targetFolder.length === 0) {
            return 0.0;
        }
        
        let exactMatches = 0;
        let fuzzyMatches = 0;
        
        for (const searchWord of searchFolder) {
            if (targetFolder.includes(searchWord)) {
                exactMatches++;
            } else {
                // Fuzzy context match
                for (const targetWord of targetFolder) {
                    if (targetWord.includes(searchWord) || searchWord.includes(targetWord)) {
                        fuzzyMatches += 0.5;
                        break;
                    }
                }
            }
        }
        
        const totalMatches = exactMatches + fuzzyMatches;
        return totalMatches / Math.max(searchFolder.length, targetFolder.length);
    }

    /**
     * PARANTEZ MATCH HESAPLAMA - √áok kritik!
     * Test sonu√ßlarƒ±na g√∂re en √∂nemli fakt√∂rlerden biri
     */
    calculateParenthesesMatch(searchWords, targetWords) {
        const searchParentheses = searchWords['parentheses_words'];
        const targetParentheses = targetWords['parentheses_words'];
        
        if (searchParentheses.length === 0 || targetParentheses.length === 0) {
            return 0.0;
        }
        
        let exactMatches = 0;
        let fuzzyMatches = 0;
        
        for (const searchWord of searchParentheses) {
            if (targetParentheses.includes(searchWord)) {
                exactMatches++;
            } else {
                // Fuzzy parantez match
                for (const targetWord of targetParentheses) {
                    if (targetWord.includes(searchWord) || searchWord.includes(targetWord)) {
                        fuzzyMatches += 0.7;
                        break;
                    }
                }
            }
        }
        
        const totalMatches = exactMatches + fuzzyMatches;
        return totalMatches / searchParentheses.length;
    }

    /**
     * REMIX PENALTY HESAPLAMA
     * Test sonu√ßlarƒ±na g√∂re remix kategorisi %12 ba≈üarƒ±
     */
    calculateRemixPenalty(searchWords, targetWords) {
        const searchFile = searchWords['file_words'];
        const targetFile = targetWords['file_words'];
        const searchParentheses = searchWords['parentheses_words'];
        const targetParentheses = targetWords['parentheses_words'];
        
        // Remix kelimeleri
        const remixWords = ['remix', 'version', 'edit', 'mix', 'bootleg', 'mashup', 'extended'];
        
        const searchHasRemix = searchFile.some(word => remixWords.includes(word)) ||
                              searchParentheses.some(word => remixWords.includes(word));
        
        const targetHasRemix = targetFile.some(word => remixWords.includes(word)) ||
                              targetParentheses.some(word => remixWords.includes(word));
        
        // Parantez kontrol√º
        const searchHasParentheses = searchParentheses.length > 0;
        const targetHasParentheses = targetParentheses.length > 0;
        
        // Remix penalty hesaplama
        let penalty = 0;
        
        if (!searchHasRemix && targetHasRemix) {
            penalty += 0.3; // Remix olmayan aramada remix dosya penalty
        }
        
        if (!searchHasParentheses && targetHasParentheses) {
            penalty += 0.2; // Parantez olmayan aramada parantezli dosya penalty
        }
        
        return penalty;
    }

    /**
     * LEVENSHTEIN DISTANCE - Basit versiyon
     */
    levenshteinDistance(str1, str2) {
        const matrix = [];
        
        for (let i = 0; i <= str2.length; i++) {
            matrix[i] = [i];
        }
        
        for (let j = 0; j <= str1.length; j++) {
            matrix[0][j] = j;
        }
        
        for (let i = 1; i <= str2.length; i++) {
            for (let j = 1; j <= str1.length; j++) {
                if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j - 1] + 1,
                        matrix[i][j - 1] + 1,
                        matrix[i - 1][j] + 1
                    );
                }
            }
        }
        
        return matrix[str2.length][str1.length];
    }

    /**
     * M√úKEMMEL BENZERLƒ∞K HESAPLAMA
     * Test sonu√ßlarƒ±na g√∂re optimize edilmi≈ü aƒüƒ±rlƒ±klar
     */
    calculatePerfectSimilarity(searchWords, targetWords) {
        if (!searchWords || !targetWords || 
            !searchWords['file_words'] || !targetWords['file_words'] ||
            searchWords['file_words'].length === 0 || targetWords['file_words'].length === 0) {
            return 0.0;
        }
        
        // 1. Exact match - en kritik (test sonu√ßlarƒ±na g√∂re)
        const exactScore = this.calculateExactMatch(searchWords, targetWords);
        
        // 2. Fuzzy match - ikinci kritik
        const fuzzyScore = this.calculateFuzzyMatch(searchWords, targetWords);
        
        // 3. Context match - klas√∂r uyumu
        const contextScore = this.calculateContextMatch(searchWords, targetWords);
        
        // 4. Parantez match - √ßok kritik! (test sonu√ßlarƒ±na g√∂re)
        const parenthesesScore = this.calculateParenthesesMatch(searchWords, targetWords);
        
        // 5. Remix penalty - remix kategorisi %12 ba≈üarƒ±
        const remixPenalty = this.calculateRemixPenalty(searchWords, targetWords);
        
        // 6. Dosya adƒ± uzunluƒüu penaltƒ±sƒ±
        let lengthPenalty = 0.0;
        const targetFileWords = targetWords['file_words'];
        const searchFileWords = searchWords['file_words'];
        
        const targetHasNumbers = targetFileWords.some(word => /^\d+$/.test(word));
        if (targetHasNumbers) {
            lengthPenalty += 0.1; // Azaltƒ±ldƒ±
        }
        
        if (targetFileWords.length > searchFileWords.length * 2) {
            const lengthRatio = targetFileWords.length / searchFileWords.length;
            lengthPenalty += Math.min(0.2, (lengthRatio - 2) * 0.05);
        }
        
        // 7. TAM E≈ûLE≈ûME BONUSU - "Sarƒ± Sarƒ±" gibi tam e≈üle≈ümeler i√ßin (DENGELƒ∞)
        let perfectMatchBonus = 0.0;
        if (exactScore >= 0.9) { // √áok y√ºksek exact match
            perfectMatchBonus = 0.1; // %10 bonus (azaltƒ±ldƒ±)
        } else if (exactScore >= 0.7) { // Y√ºksek exact match
            perfectMatchBonus = 0.05; // %5 bonus (azaltƒ±ldƒ±)
        }
        
        // 8. Final score hesaplama - test sonu√ßlarƒ±na g√∂re optimize edilmi≈ü aƒüƒ±rlƒ±klar
        const baseScore = (exactScore * 0.40) +           // Azaltƒ±ldƒ±
                         (fuzzyScore * 0.20) +            // Azaltƒ±ldƒ±
                         (contextScore * 0.05) +          // Aynƒ±
                         (parenthesesScore * 0.35) +      // Artƒ±rƒ±ldƒ± - √ßok kritik!
                         perfectMatchBonus;               // TAM E≈ûLE≈ûME BONUSU!
        
        const finalScore = Math.max(0.0, baseScore - lengthPenalty - remixPenalty);
        
        // 8. Minimum threshold - √ßok d√º≈ü√ºk
        if (exactScore < 0.01 && fuzzyScore < 0.05 && parenthesesScore < 0.01) {
            return 0.0;
        }
        
        return Math.max(0.0, Math.min(1.0, finalScore));
    }

    /**
     * M√úKEMMEL ARAMA FONKSƒ∞YONU
     */
    async searchPerfectMatch(searchPath, options = {}) {
        const db = await this.loadDatabase();
        if (!db) return { found: false, matches: [] };

        const fileName = path.basename(searchPath);
        const searchWords = this.extractPerfectWords(fileName, searchPath);
        
        const threshold = options.threshold || 0.01;
        const limit = options.limit || 10;
        
        let candidates = [];
        let processedCount = 0;
        
        console.log(`üîç M√ºkemmel algoritma ile arama: [${searchWords.file_words.join(', ')}]`);
        if (searchWords.parentheses_words.length > 0) {
            console.log(`üì¶ Parantez kelimeleri: [${searchWords.parentheses_words.join(', ')}]`);
        }
        
        const startTime = Date.now();
        
        for (const file of db.musicFiles) {
            processedCount++;
            
            const targetWords = {
                'folder_words': file.folderWords,
                'file_words': file.fileWords,
                'parentheses_words': file.parenthesesWords || [],
                'all_words': [...file.folderWords, ...file.fileWords, ...(file.parenthesesWords || [])]
            };
            
            const similarity = this.calculatePerfectSimilarity(searchWords, targetWords);
            
            if (similarity >= threshold) {
                candidates.push({
                    path: file.path,
                    name: file.name,
                    similarity: similarity,
                    file: file,
                    matchDetails: {
                        exactScore: this.calculateExactMatch(searchWords, targetWords),
                        fuzzyScore: this.calculateFuzzyMatch(searchWords, targetWords),
                        contextScore: this.calculateContextMatch(searchWords, targetWords),
                        parenthesesScore: this.calculateParenthesesMatch(searchWords, targetWords),
                        remixPenalty: this.calculateRemixPenalty(searchWords, targetWords)
                    }
                });
            }
        }
        
        // M√úKEMMEL SIRALAMA - test sonu√ßlarƒ±na g√∂re optimize edildi
        candidates.sort((a, b) => {
            // 1. Benzerlik skoruna g√∂re
            if (Math.abs(a.similarity - b.similarity) > 0.001) {
                return b.similarity - a.similarity;
            }
            
            // 2. Exact match sayƒ±sƒ±na g√∂re
            const aExact = a.matchDetails.exactScore;
            const bExact = b.matchDetails.exactScore;
            if (Math.abs(aExact - bExact) > 0.01) {
                return bExact - aExact;
            }
            
            // 3. Parantez skoruna g√∂re
            const aParentheses = a.matchDetails.parenthesesScore;
            const bParentheses = b.matchDetails.parenthesesScore;
            if (Math.abs(aParentheses - bParentheses) > 0.01) {
                return bParentheses - aParentheses;
            }
            
            // 4. Dosya adƒ± uzunluƒüuna g√∂re (daha kƒ±sa = daha spesifik)
            const aLength = a.file.fileNameOnly.length;
            const bLength = b.file.fileNameOnly.length;
            if (Math.abs(aLength - bLength) > 5) {
                return aLength - bLength;
            }
            
            // 5. Remix penalty'ye g√∂re (daha az penalty = daha iyi)
            const aRemixPenalty = a.matchDetails.remixPenalty;
            const bRemixPenalty = b.matchDetails.remixPenalty;
            return aRemixPenalty - bRemixPenalty;
        });
        
        const totalTime = Date.now() - startTime;
        console.log(`‚è±Ô∏è Toplam s√ºre: ${totalTime}ms (${(processedCount / totalTime * 1000).toFixed(0)} dosya/sn)`);
        
        const matches = candidates.slice(0, limit).map(candidate => ({
            path: candidate.path,
            name: candidate.name,
            similarity: candidate.similarity,
            matchDetails: candidate.matchDetails
        }));
        
        return {
            found: matches.length > 0,
            matches: matches,
            totalProcessed: processedCount,
            searchTime: totalTime
        };
    }

    /**
     * PERFORMANS ƒ∞STATƒ∞STƒ∞KLERƒ∞
     */
    getPerformanceStats() {
        return this.performanceStats;
    }

    /**
     * TEST FONKSƒ∞YONU
     */
    async testAlgorithm(testFiles) {
        console.log('üß™ M√úKEMMEL ALGORƒ∞TMA TEST Sƒ∞STEMƒ∞');
        console.log('='.repeat(50));
        
        const results = [];
        
        for (let i = 0; i < testFiles.length; i++) {
            const testFile = testFiles[i];
            console.log(`\n[${i + 1}/${testFiles.length}] ${path.basename(testFile)}`);
            
            const result = await this.searchPerfectMatch(testFile, { threshold: 0.01, limit: 5 });
            
            results.push({
                file: testFile,
                result: result
            });
            
            if (result.found) {
                console.log(`‚úÖ En iyi e≈üle≈üme: ${result.matches[0].similarity.toFixed(4)} - ${path.parse(result.matches[0].name).name}`);
                console.log(`üìä Skorlar: E:${result.matches[0].matchDetails.exactScore.toFixed(3)} F:${result.matches[0].matchDetails.fuzzyScore.toFixed(3)} P:${result.matches[0].matchDetails.parenthesesScore.toFixed(3)}`);
            } else {
                console.log(`‚ùå E≈üle≈üme bulunamadƒ±`);
            }
        }
        
        return results;
    }
}

// CLI kullanƒ±mƒ±
if (require.main === module) {
    const algorithm = new PerfectSimilarityAlgorithm();
    
    const command = process.argv[2];
    
    async function main() {
        try {
            if (command === 'test') {
                const testFiles = [
                    '/Users/koray/Music/KorayMusics/Video2019/Mahsun Kƒ±rmƒ±zƒ±g√ºl - Sarƒ± Sarƒ±.m4a',
                    '/Users/koray/Documents/VirtualDJ/Cache/CloudDrive/Loboda - Pulia Dura (Eddie G & Roma YNG Moombahton Remix) (1).mp3',
                    '/Users/koray/Music/KorayMusics/SahitHoca/bachata kizomba hitt/Massimo Scalic - Massimo Scalici (Roxanne Bachata Version).mp3'
                ];
                await algorithm.testAlgorithm(testFiles);
            } else if (command === 'single') {
                const testFile = process.argv[3];
                if (testFile) {
                    const result = await algorithm.searchPerfectMatch(testFile, { threshold: 0.01, limit: 10 });
                    console.log('\nüìä SONU√áLAR:');
                    console.log(JSON.stringify(result, null, 2));
                } else {
                    console.log('Kullanƒ±m: node perfect_similarity_algorithm.js single <dosya_yolu>');
                }
            } else {
                console.log('üîß M√úKEMMEL BENZERLƒ∞K ALGORƒ∞TMASI');
                console.log('='.repeat(40));
                console.log('Kullanƒ±m:');
                console.log('  node perfect_similarity_algorithm.js test        # Test dosyalarƒ±');
                console.log('  node perfect_similarity_algorithm.js single <path> # Tek dosya test');
            }
        } catch (error) {
            console.error('‚ùå Fatal error:', error);
        }
    }
    
    main();
}

module.exports = PerfectSimilarityAlgorithm;

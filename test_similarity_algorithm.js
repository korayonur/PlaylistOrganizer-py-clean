/**
 * Benzerlik Arama Algoritmasƒ± Test Dosyasƒ±
 * Mantƒ±k hatalarƒ±nƒ± tespit etmek i√ßin kapsamlƒ± testler
 */

const path = require('path');

// Test i√ßin gerekli fonksiyonlarƒ± import et
const CHAR_MAP = {
    // Latin Alfabesi Geni≈ületilmi≈ü
    "√†": "a", "√°": "a", "√¢": "a", "√£": "a", "√§": "a", "√•": "a", "√¶": "ae",
    "√ß": "c", "ƒá": "c", "ƒç": "c", "ƒè": "d", "√®": "e", "√©": "e", "√™": "e", "√´": "e",
    "√¨": "i", "√≠": "i", "√Æ": "i", "√Ø": "i", "√∞": "d", "√±": "n", "√≤": "o", "√≥": "o",
    "√¥": "o", "√µ": "o", "√∂": "o", "√∏": "o", "√π": "u", "√∫": "u", "√ª": "u", "√º": "u",
    "√Ω": "y", "√æ": "th", "√ø": "y", "ƒü": "g", "ƒ±": "i", "ƒ∞": "I", "≈ü": "s",
    "≈†": "S", "≈æ": "z", "√ü": "ss"
};

function normalizeText(text, options = {}) {
    if (typeof text !== 'string') {
        throw new TypeError("Input must be a string");
    }

    const keepSpaces = options.keepSpaces !== false;
    const keepSpecialChars = options.keepSpecialChars || false;
    const keepCase = options.keepCase || false;
    const keepDiacritics = options.keepDiacritics || false;

    let normalized = text;

    if (!keepDiacritics) {
        normalized = normalized.normalize("NFKC");
        normalized = normalized.split('').map(c => CHAR_MAP[c.toLowerCase()] || c).join('');
    }

    if (!keepCase) {
        normalized = normalized.toLowerCase();
    }

    if (!keepSpecialChars) {
        normalized = normalized.replace(/[^a-zA-Z0-9\s]/g, '');
    }

    if (!keepSpaces) {
        normalized = normalized.replace(/\s+/g, ' ');
    }

    return normalized.trim();
}

function extractImprovedWords(fileName, filePath = "") {
    const pathParts = path.dirname(filePath).split(path.sep).filter(p => p && p !== "." && !p.startsWith("/"));
    
    const relevantFolders = pathParts;
    
    const fileNameWithoutExt = path.parse(fileName).name;
    const fileNameParts = fileNameWithoutExt.split(/[-_]/).map(part => part.trim());
    
    const folderWords = [];
    for (const folder of relevantFolders) {
        const normalizedFolder = normalizeText(folder, { keepSpaces: false });
        const camelCaseWords = normalizedFolder.replace(/([a-z])([A-Z])/g, '$1 $2');
        folderWords.push(...camelCaseWords.split(/\s+/).filter(w => w.length > 1));
    }
    
    const fileWords = [];
    for (const part of fileNameParts) {
        const normalizedPart = normalizeText(part, { keepSpaces: false });
        fileWords.push(...normalizedPart.split(/\s+/).filter(w => w.length > 1));
    }
    
    const result = {
        'folder_words': folderWords,
        'file_words': fileWords,
        'all_words': [...folderWords, ...fileWords]
    };
    
    return result;
}

function calculateImprovedSimilarity(searchWords, targetWords) {
    if (!searchWords['all_words'] || !targetWords['all_words'] || 
        searchWords['all_words'].length === 0 || targetWords['all_words'].length === 0) {
        return 0.0;
    }
    
    const fileSearch = searchWords['file_words'] || [];
    const fileTarget = targetWords['file_words'] || [];
    
    if (!fileSearch || !fileTarget || fileSearch.length === 0 || fileTarget.length === 0) {
        return 0.0;
    }
    
    let exactFileMatches = 0;
    for (const word of fileSearch) {
        if (fileTarget.includes(word)) {
            exactFileMatches += 1.0;
        }
    }
    
    // Kelime birle≈ütirme + harf e≈üle≈üme algoritmasƒ±
    for (const word of fileSearch) {
        if (!fileTarget.includes(word)) {
            let bestCombinationScore = 0;
            
            for (let i = 1; i < word.length; i++) {
                const part1 = word.substring(0, i);
                const part2 = word.substring(i);
                
                const part1Index = fileTarget.findIndex(w => w.toLowerCase() === part1.toLowerCase());
                const part2Index = fileTarget.findIndex(w => w.toLowerCase() === part2.toLowerCase());
                
                if (part1Index !== -1 && part2Index !== -1) {
                    bestCombinationScore = Math.max(bestCombinationScore, 1.0);
                } else {
                    const combinedWord = part1 + ' ' + part2;
                    const searchChars = word.toLowerCase().split('');
                    const targetChars = combinedWord.toLowerCase().split('');
                    
                    const searchCharCount = {};
                    const targetCharCount = {};
                    
                    searchChars.forEach(char => {
                        searchCharCount[char] = (searchCharCount[char] || 0) + 1;
                    });
                    
                    targetChars.forEach(char => {
                        targetCharCount[char] = (targetCharCount[char] || 0) + 1;
                    });
                    
                    let minCharCount = 0;
                    for (const char in searchCharCount) {
                        if (targetCharCount[char]) {
                            minCharCount += Math.min(searchCharCount[char], targetCharCount[char]);
                        }
                    }
                    
                    const charSimilarity = minCharCount / Math.max(searchChars.length, targetChars.length);
                    
                    if (charSimilarity > 0.6) {
                        bestCombinationScore = Math.max(bestCombinationScore, charSimilarity);
                    }
                }
            }
            
            if (bestCombinationScore > 0) {
                exactFileMatches += bestCombinationScore;
            }
        }
    }
    
    // Harf bazlƒ± e≈üle≈üme
    let charSimilarity = 0;
    let charMatches = 0;
    
    for (const searchWord of fileSearch) {
        for (const targetWord of fileTarget) {
            const searchChars = searchWord.toLowerCase().split('');
            const targetChars = targetWord.toLowerCase().split('');
            
            const commonChars = searchChars.filter(char => targetChars.includes(char));
            const wordSimilarity = commonChars.length / Math.max(searchChars.length, targetChars.length);
            
            if (wordSimilarity > 0.3) {
                charSimilarity += wordSimilarity;
                charMatches++;
            }
        }
    }
    
    // ƒ∞√ßerme kontrol√º
    for (const searchWord of fileSearch) {
        for (const targetWord of fileTarget) {
            if (targetWord.toLowerCase().includes(searchWord.toLowerCase()) && searchWord.length >= 3) {
                charSimilarity += 0.8;
                charMatches++;
            }
        }
    }
    
    if (charMatches > 0) {
        charSimilarity = charSimilarity / charMatches;
    }
    
    const totalMatches = exactFileMatches + Math.floor(charSimilarity * 2);
    const fileScore = totalMatches / Math.max(fileSearch.length, fileTarget.length);
    
    if (totalMatches < 1) {
        return 0.0;
    }
    
    // Klas√∂r kelime e≈üle≈ümesi (Bonus)
    const folderSearch = searchWords['folder_words'] || [];
    const folderTarget = targetWords['folder_words'] || [];
    
    let folderBonus = 0.0;
    if (folderSearch.length > 0 && folderTarget.length > 0) {
        const exactFolderMatches = folderSearch.filter(word => folderTarget.includes(word)).length;
        folderBonus = (exactFolderMatches / Math.max(folderSearch.length, folderTarget.length)) * 0.3;
    }
    
    let fullMatchBonus = 0.0;
    if (exactFileMatches >= 3) {
        fullMatchBonus = 0.15;
    }
    
    const totalScore = fileScore + folderBonus + fullMatchBonus;
    
    return Math.max(0.0, Math.min(1.0, totalScore));
}

// Test API fonksiyonu
async function callSearchAPI(searchPaths) {
    const response = await fetch('http://localhost:50001/api/search/files', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            paths: searchPaths,
            options: {}
        })
    });
    
    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return await response.json();
}

// Test senaryolarƒ±
const testCases = [
    {
        name: "Kenan Doƒüulu - Gel Gelinim Test",
        searchPath: "/Users/koray/Music/KorayMusics/galadugun/M√úZƒ∞KAL G√ñR√ú≈ûME/ƒ∞LK DANS/Kenan Doƒüulu_Gel Gelinim.mp3",
        expectedMatches: [
            "Kenan Doƒüulu - Gelinim.m4a",
            "Kenan Doƒüulu - Gel Gelinim",
            "gelinim"
        ]
    },
    {
        name: "Mahsun Kƒ±rmƒ±zƒ±g√ºl - Sarƒ± Sarƒ± Test", 
        searchPath: "/Users/koray/Music/KorayMusics/Video2019/Mahsun Kƒ±rmƒ±zƒ±g√ºl - Sarƒ± Sarƒ±.m4a",
        expectedMatches: [
            "Mahsun Kƒ±rmƒ±zƒ±g√ºl",
            "Sarƒ± Sarƒ±",
            "sari"
        ]
    },
    {
        name: "Sezen Aksu - Kutlama Test",
        searchPath: "/Users/koray/Music/KorayMusics/Videodown3/Sezen Aksu - Kutlama (Official Audio).mp4",
        expectedMatches: [
            "Sezen Aksu",
            "Kutlama"
        ]
    }
];

// Kelime √ßƒ±karma testleri
function testWordExtraction() {
    console.log("\nüîç KELƒ∞ME √áIKARMA TESTLERƒ∞");
    console.log("=" * 50);
    
    const testFiles = [
        {
            fileName: "Kenan Doƒüulu_Gel Gelinim.mp3",
            filePath: "/Users/koray/Music/KorayMusics/galadugun/M√úZƒ∞KAL G√ñR√ú≈ûME/ƒ∞LK DANS/Kenan Doƒüulu_Gel Gelinim.mp3"
        },
        {
            fileName: "Kenan Doƒüulu - Gelinim.m4a", 
            filePath: "/Users/koray/Music/KorayMusics/1 - D√úƒû√úN/SLOW/Kenan Doƒüulu - Gelinim.m4a"
        },
        {
            fileName: "tabiki.mp3",
            filePath: "/Users/koray/Music/test/tabiki.mp3"
        }
    ];
    
    testFiles.forEach((testFile, index) => {
        console.log(`\nüìÅ Test ${index + 1}: ${testFile.fileName}`);
        const words = extractImprovedWords(testFile.fileName, testFile.filePath);
        console.log(`   üìÇ Klas√∂r kelimeleri: ${JSON.stringify(words.folder_words)}`);
        console.log(`   üìÑ Dosya kelimeleri: ${JSON.stringify(words.file_words)}`);
        console.log(`   üîó T√ºm kelimeler: ${JSON.stringify(words.all_words)}`);
    });
}

// Benzerlik hesaplama testleri
function testSimilarityCalculation() {
    console.log("\nüßÆ BENZERLƒ∞K HESAPLAMA TESTLERƒ∞");
    console.log("=" * 50);
    
    const searchWords = extractImprovedWords("Kenan Doƒüulu_Gel Gelinim.mp3", 
        "/Users/koray/Music/KorayMusics/galadugun/M√úZƒ∞KAL G√ñR√ú≈ûME/ƒ∞LK DANS/Kenan Doƒüulu_Gel Gelinim.mp3");
    
    const testTargets = [
        {
            name: "Kenan Doƒüulu - Gelinim.m4a",
            path: "/Users/koray/Music/KorayMusics/1 - D√úƒû√úN/SLOW/Kenan Doƒüulu - Gelinim.m4a"
        },
        {
            name: "Kenan Doƒüulu - Tabii Ki.m4a", 
            path: "/Users/koray/Music/KorayMusics/1 - D√úƒû√úN/SLOW/Kenan Doƒüulu - Tabii Ki.m4a"
        },
        {
            name: "Sezen Aksu - Kutlama.mp3",
            path: "/Users/koray/Music/KorayMusics/test/Sezen Aksu - Kutlama.mp3"
        }
    ];
    
    console.log(`\nüîç Arama dosyasƒ±: Kenan Doƒüulu_Gel Gelinim.mp3`);
    console.log(`üìù Arama kelimeleri: ${JSON.stringify(searchWords)}`);
    
    testTargets.forEach((target, index) => {
        console.log(`\nüéØ Hedef ${index + 1}: ${target.name}`);
        const targetWords = extractImprovedWords(target.name, target.path);
        console.log(`üìù Hedef kelimeler: ${JSON.stringify(targetWords)}`);
        
        const similarity = calculateImprovedSimilarity(searchWords, targetWords);
        console.log(`üíØ Benzerlik skoru: ${similarity.toFixed(4)}`);
        
        // Detaylƒ± analiz
        const fileSearch = searchWords['file_words'] || [];
        const fileTarget = targetWords['file_words'] || [];
        
        console.log(`üîé Dosya kelimeleri kar≈üƒ±la≈ütƒ±rmasƒ±:`);
        console.log(`   Arama: ${JSON.stringify(fileSearch)}`);
        console.log(`   Hedef: ${JSON.stringify(fileTarget)}`);
        
        // Tam e≈üle≈üme analizi
        let exactMatches = 0;
        fileSearch.forEach(word => {
            if (fileTarget.includes(word)) {
                exactMatches++;
                console.log(`   ‚úÖ Tam e≈üle≈üme: "${word}"`);
            }
        });
        
        console.log(`   üìä Tam e≈üle≈üme sayƒ±sƒ±: ${exactMatches}/${fileSearch.length}`);
    });
}

// API testleri
async function testSearchAPI() {
    console.log("\nüåê API ARAMA TESTLERƒ∞");
    console.log("=" * 50);
    
    for (const testCase of testCases) {
        console.log(`\nüîç Test: ${testCase.name}`);
        console.log(`üìÅ Arama yolu: ${testCase.searchPath}`);
        
        try {
            const result = await callSearchAPI([testCase.searchPath]);
            
            if (result.status === 'success' && result.data && result.data.length > 0) {
                const searchResult = result.data[0];
                
                console.log(`‚úÖ Sonu√ß: ${searchResult.found ? 'BULUNDU' : 'BULUNAMADI'}`);
                
                if (searchResult.found) {
                    console.log(`üéØ Bulunan dosya: ${searchResult.foundPath}`);
                    console.log(`üíØ Benzerlik: ${searchResult.similarity}`);
                    console.log(`üîß E≈üle≈üme tipi: ${searchResult.matchType}`);
                    
                    if (searchResult.debugInfo && searchResult.debugInfo.matchDetails) {
                        const details = searchResult.debugInfo.matchDetails;
                        console.log(`üìä Detaylar:`);
                        console.log(`   - Tam e≈üle≈üme: ${details.exactFileMatches}`);
                        console.log(`   - Harf benzerliƒüi: ${details.charSimilarity?.toFixed(4)}`);
                        console.log(`   - Toplam e≈üle≈üme: ${details.totalMatches}`);
                        console.log(`   - Dosya skoru: ${details.fileScore?.toFixed(4)}`);
                    }
                } else {
                    console.log(`‚ùå Durum: ${searchResult.status}`);
                }
            } else {
                console.log(`‚ùå API Hatasƒ±: ${result.message || 'Bilinmeyen hata'}`);
            }
            
        } catch (error) {
            console.log(`‚ùå Baƒülantƒ± hatasƒ±: ${error.message}`);
        }
        
        // Test arasƒ± bekleme
        await new Promise(resolve => setTimeout(resolve, 1000));
    }
}

// Mantƒ±k hatasƒ± analizi
function analyzeLogicErrors() {
    console.log("\nüêõ MANTIK HATASI ANALƒ∞Zƒ∞");
    console.log("=" * 50);
    
    const potentialErrors = [
        {
            error: "Kelime birle≈ütirme algoritmasƒ± 'gelinim' kelimesini 'gel' + 'inim' olarak ayƒ±rabilir",
            impact: "Yanlƒ±≈ü e≈üle≈ümelere neden olabilir",
            severity: "Orta"
        },
        {
            error: "Harf e≈üle≈üme threshold'u (%30) √ßok d√º≈ü√ºk olabilir",
            impact: "√áok fazla false positive",
            severity: "Y√ºksek"
        },
        {
            error: "Klas√∂r kelimelerinin aƒüƒ±rlƒ±ƒüƒ± √ßok d√º≈ü√ºk (%30 bonus)",
            impact: "√ñnemli context bilgisi kaybƒ±",
            severity: "Orta"
        },
        {
            error: "Minimum e≈üle≈üme ko≈üulu (totalMatches < 1) √ßok katƒ±",
            impact: "Bazƒ± ge√ßerli e≈üle≈ümeler ka√ßƒ±rƒ±labilir",
            severity: "Y√ºksek"
        },
        {
            error: "Normalizasyon sƒ±rasƒ±nda √∂zel karakterler kaldƒ±rƒ±lƒ±yor",
            impact: "T√ºrk√ße karakter desteƒüi eksikliƒüi",
            severity: "Orta"
        }
    ];
    
    potentialErrors.forEach((error, index) => {
        console.log(`\n‚ùó Hata ${index + 1}: ${error.error}`);
        console.log(`   üìà Etki: ${error.impact}`);
        console.log(`   ‚ö†Ô∏è  √ñnem: ${error.severity}`);
    });
    
    console.log("\nüí° √ñNERƒ∞LER:");
    console.log("1. Kelime birle≈ütirme algoritmasƒ±nda minimum kelime uzunluƒüu kontrol√º ekle");
    console.log("2. Harf e≈üle≈üme threshold'unu %50'ye √ßƒ±kar");
    console.log("3. T√ºrk√ße karakterler i√ßin √∂zel normalizasyon kurallarƒ± ekle");
    console.log("4. Klas√∂r kelimelerinin aƒüƒ±rlƒ±ƒüƒ±nƒ± artƒ±r");
    console.log("5. Fuzzy matching algoritmasƒ± ekle");
}

// Ana test fonksiyonu
async function runAllTests() {
    console.log("üß™ BENZERLƒ∞K ARAMA ALGORƒ∞TMASI TEST PAKETƒ∞");
    console.log("=" * 60);
    console.log(`üìÖ Test tarihi: ${new Date().toLocaleString('tr-TR')}`);
    console.log(`üîß Test versiyonu: 1.0.0`);
    
    try {
        // 1. Kelime √ßƒ±karma testleri
        testWordExtraction();
        
        // 2. Benzerlik hesaplama testleri  
        testSimilarityCalculation();
        
        // 3. API testleri
        await testSearchAPI();
        
        // 4. Mantƒ±k hatasƒ± analizi
        analyzeLogicErrors();
        
        console.log("\n‚úÖ T√úM TESTLER TAMAMLANDI");
        
    } catch (error) {
        console.error("\n‚ùå TEST HATASI:", error.message);
        console.error(error.stack);
    }
}

// Eƒüer doƒürudan √ßalƒ±≈ütƒ±rƒ±lƒ±yorsa testleri ba≈ülat
if (require.main === module) {
    // Node.js fetch polyfill
    if (typeof fetch === 'undefined') {
        global.fetch = require('node-fetch');
    }
    
    runAllTests().then(() => {
        console.log("\nüéâ Test paketi ba≈üarƒ±yla tamamlandƒ±!");
        process.exit(0);
    }).catch(error => {
        console.error("\nüí• Test paketi hatasƒ±:", error);
        process.exit(1);
    });
}

module.exports = {
    normalizeText,
    extractImprovedWords,
    calculateImprovedSimilarity,
    runAllTests
};

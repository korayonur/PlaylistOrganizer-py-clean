/**
 * BENZERLƒ∞K ALGORƒ∞TMASI TEST Sƒ∞STEMƒ∞
 * Yapƒ±lan deƒüi≈üikliklerin doƒüru √ßalƒ±≈üƒ±p √ßalƒ±≈ümadƒ±ƒüƒ±nƒ± test eder
 */

const axios = require('axios');
const path = require('path');
const fs = require('fs');

class SimilarityFixTester {
    constructor() {
        this.apiUrl = 'http://localhost:50001';
        this.tests = [];
        this.results = [];
        this.musicDatabase = null;
    }

    /**
     * Veritabanƒ±nƒ± y√ºkle
     */
    async loadDatabase() {
        if (this.musicDatabase) return this.musicDatabase;
        
        try {
            const dbPath = '/Users/koray/projects/PlaylistOrganizer-py/musicfiles.db.json';
            const dbData = JSON.parse(fs.readFileSync(dbPath, 'utf8'));
            this.musicDatabase = dbData;
            console.log(`üìä Veritabanƒ± y√ºklendi: ${dbData.musicFiles.length} dosya`);
            return dbData;
        } catch (error) {
            console.error('‚ùå Veritabanƒ± y√ºkleme hatasƒ±:', error.message);
            return null;
        }
    }

    /**
     * Manuel benzerlik hesaplama (server.js'deki algoritmanƒ±n GER√áEK kopyasƒ±)
     */
    calculateManualSimilarity(searchWords, targetWords) {
        // Exact match
        const searchFile = searchWords.file_words;
        const targetFile = targetWords.file_words;
        
        if (searchFile.length === 0 || targetFile.length === 0) {
            return 0.0;
        }
        
        let exactMatches = 0;
        for (const searchWord of searchFile) {
            if (targetFile.includes(searchWord)) {
                exactMatches++;
            }
        }
        const exactScore = exactMatches / searchFile.length;
        
        // Fuzzy match (server.js ile aynƒ±)
        let fuzzyScore = 0;
        let comparisons = 0;
        for (const searchWord of searchFile) {
            let bestSimilarity = 0;
            for (const targetWord of targetFile) {
                // Substring kontrol√º
                if (targetWord.includes(searchWord) && searchWord.length >= 3) {
                    bestSimilarity = Math.max(bestSimilarity, 0.8);
                }
                if (searchWord.includes(targetWord) && targetWord.length >= 3) {
                    bestSimilarity = Math.max(bestSimilarity, 0.7);
                }
            }
            if (bestSimilarity > 0) {
                fuzzyScore += bestSimilarity;
                comparisons++;
            }
        }
        fuzzyScore = comparisons > 0 ? fuzzyScore / comparisons : 0.0;
        
        // Context match
        const searchFolder = searchWords.folder_words;
        const targetFolder = targetWords.folder_words;
        let contextScore = 0.0;
        if (searchFolder.length > 0 && targetFolder.length > 0) {
            let exactFolderMatches = 0;
            for (const searchWord of searchFolder) {
                if (targetFolder.includes(searchWord)) {
                    exactFolderMatches++;
                }
            }
            contextScore = exactFolderMatches / Math.max(searchFolder.length, targetFolder.length);
        }
        
        // Special match (basit versiyon)
        let specialScore = 0.0;
        for (const searchWord of searchFile) {
            for (const targetWord of targetFile) {
                // Kelime i√ßerme kontrol√º
                if (targetWord.includes(searchWord) && searchWord.length >= 3) {
                    specialScore += 0.8;
                } else if (searchWord.includes(targetWord) && targetWord.length >= 3) {
                    specialScore += 0.7;
                }
            }
        }
        specialScore = specialScore > 0 ? specialScore / Math.max(searchFile.length, targetFile.length) : 0.0;
        
        // Parantez match (√ñNEMLƒ∞!)
        let parenthesesScore = 0.0;
        const searchParentheses = searchWords.parentheses_words;
        const targetParentheses = targetWords.parentheses_words;
        
        if (searchParentheses.length > 0 && targetParentheses.length > 0) {
            let parenthesesMatches = 0;
            for (const searchWord of searchParentheses) {
                if (targetParentheses.includes(searchWord)) {
                    parenthesesMatches++;
                }
            }
            parenthesesScore = parenthesesMatches / searchParentheses.length;
        }
        
        // Server.js ile aynƒ± final score hesaplama
        const baseScore = (exactScore * 0.4) + (fuzzyScore * 0.2) + (contextScore * 0.05) + (specialScore * 0.15) + (parenthesesScore * 0.2);
        return Math.max(0.0, Math.min(1.0, baseScore));
    }

    /**
     * Kelime √ßƒ±karma (server.js'deki extractImprovedWords ile TAM AYNI)
     */
    extractWords(fileName, filePath) {
        const ENHANCED_CHAR_MAP = {
            "ƒü": "g", "ƒû": "G", "ƒ±": "i", "I": "I", "ƒ∞": "I", "≈ü": "s", "≈û": "S",
            "√ß": "c", "√á": "C", "√º": "u", "√ú": "U", "√∂": "o", "√ñ": "O"
        };
        
        function normalizeText(text, options = {}) {
            if (typeof text !== 'string') return '';
            
            const keepSpaces = options.keepSpaces !== false;
            let normalized = text;
            
            // NFKC normalizasyonu ve karakter d√∂n√º≈ü√ºm√º
            normalized = normalized.normalize("NFKC");
            normalized = normalized.split('').map(c => ENHANCED_CHAR_MAP[c] || c).join('');
            normalized = normalized.toLowerCase();
            normalized = normalized.replace(/[^a-zA-Z0-9\s]/g, '');
            normalized = normalized.replace(/\s+/g, ' ');
            
            return normalized.trim();
        }

        function hybridParenthesesFilter(text) {
            // Ana metni parantezlerden temizle
            const mainText = text
                .replace(/\([^)]*\)/g, '')
                .replace(/\[[^\]]*\]/g, '')
                .replace(/\{[^}]*\}/g, '')
                .replace(/\s+/g, ' ')
                .trim();
            
            // Parantez i√ßeriklerini √ßƒ±kar
            const parenthesesMatches = text.match(/\([^)]*\)/g) || [];
            const bracketMatches = text.match(/\[[^\]]*\]/g) || [];
            const braceMatches = text.match(/\{[^}]*\}/g) || [];
            
            const allMatches = [...parenthesesMatches, ...bracketMatches, ...braceMatches];
            
            const importantParenthesesWords = [];
            const noiseWords = [
                'official', 'audio', 'video', 'music', 'hd', 'stereo', 'mono',
                'remaster', 'remastered', 'enhanced', 'deluxe', 'high', 'quality',
                'feat', 'featuring', 'ft', 'with', 'vs', 'and', 've', 'ile',
                'youtube', 'spotify', 'apple', 'lyric', 'lyrics', 'karaoke',
                'resmi', 'muzik', 'sarki', 'klip', 'canli', 'performans'
            ];
            
            allMatches.forEach(match => {
                const content = match.replace(/[\(\)\[\]\{\}]/g, '');
                const words = content.split(/[\s\-_,&]+/).filter(w => w.length > 1);
                
                words.forEach(word => {
                    const normalizedWord = normalizeText(word, { keepSpaces: false });
                    
                    const isNoise = noiseWords.includes(normalizedWord);
                    const isNumber = /^\d{1,4}$/.test(normalizedWord);
                    
                    if (!isNoise && !isNumber && normalizedWord.length >= 3) {
                        importantParenthesesWords.push(normalizedWord);
                    }
                });
            });
            
            return {
                mainText: mainText,
                parenthesesWords: importantParenthesesWords
            };
        }
        
        const pathParts = path.dirname(filePath).split(path.sep).filter(p => p && p !== "." && !p.startsWith("/"));
        const relevantFolders = pathParts;
        
        // Dosya adƒ±nƒ± normalize et
        const fileNameWithoutExt = path.parse(fileName).name;
        
        // PARANTEZ ƒ∞√áƒ∞ SAYI NORMALIZASYONU
        const cleanedNameForParentheses = fileNameWithoutExt.replace(/\(\d+\)/g, '').trim();
        
        // Hƒ∞BRƒ∞T PARANTEZ Sƒ∞STEMƒ∞
        const hybridFiltered = hybridParenthesesFilter(cleanedNameForParentheses);
        const cleanedFileName = hybridFiltered.mainText;
        
        // Kelime ayƒ±rma
        const fileNameParts = cleanedFileName.split(/[-_\s\.\,\&\+\|\~\!\@\#\$\%\^\*\(\)\[\]\{\}]+/).map(part => part.trim()).filter(part => part.length > 0);
        
        // Klas√∂r kelimelerini normalize et
        const folderWords = [];
        for (const folder of relevantFolders) {
            const normalizedFolder = normalizeText(folder, { keepSpaces: false });
            const camelCaseWords = normalizedFolder.replace(/([a-z])([A-Z])/g, '$1 $2');
            folderWords.push(...camelCaseWords.split(/\s+/).filter(w => w.length > 1));
        }
        
        // Dosya adƒ± kelimelerini normalize et
        const fileWords = [];
        for (const part of fileNameParts) {
            if (part.trim()) {
                const normalizedPart = normalizeText(part, { keepSpaces: false });
                const words = normalizedPart.split(/\s+/).filter(w => w.length > 1);
                fileWords.push(...words);
            }
        }
        
        // Parantez kelimeleri
        const parenthesesWords = hybridFiltered.parenthesesWords;
        
        return {
            folder_words: folderWords,
            file_words: fileWords,
            parentheses_words: parenthesesWords, // Artƒ±k ger√ßek parantez kelimeleri
            all_words: [...folderWords, ...fileWords, ...parenthesesWords]
        };
    }

    /**
     * Veritabanƒ±nda en iyi e≈üle≈ümeyi manuel olarak bul
     */
    async findBestManualMatch(searchPath, threshold = 0.01) {
        const db = await this.loadDatabase();
        if (!db) return null;

        const fileName = path.basename(searchPath);
        const searchWords = this.extractWords(fileName, searchPath);
        
        let bestMatch = null;
        let bestSimilarity = 0;
        
        console.log(`   üîç Manuel analiz: ${searchWords.file_words.join(', ')}`);
        
        let processedCount = 0;
        for (const file of db.musicFiles) {
            processedCount++;
            
            // Her 10000 dosyada progress g√∂ster
            if (processedCount % 10000 === 0) {
                console.log(`   üìä ƒ∞≈ülenen: ${processedCount}/${db.musicFiles.length}`);
            }
            
            const targetWords = {
                folder_words: file.folderWords,
                file_words: file.fileWords,
                parentheses_words: file.parenthesesWords || [],
                all_words: [...file.folderWords, ...file.fileWords, ...(file.parenthesesWords || [])]
            };
            
            const similarity = this.calculateManualSimilarity(searchWords, targetWords);
            
            if (similarity > bestSimilarity && similarity >= threshold) {
                bestSimilarity = similarity;
                bestMatch = {
                    path: file.path,
                    name: file.name,
                    similarity: similarity,
                    file: file
                };
                
                // Debug: En iyi e≈üle≈üme g√ºncellendiƒüinde log
                if (similarity > 0.7) {
                    console.log(`   üéØ Yeni en iyi: ${similarity.toFixed(4)} - ${file.name}`);
                }
            }
        }
        
        if (bestMatch) {
            console.log(`   ‚úÖ Manuel en iyi: ${bestMatch.similarity.toFixed(4)} - ${bestMatch.name}`);
        } else {
            console.log(`   ‚ùå Manuel e≈üle≈üme bulunamadƒ± (threshold: ${threshold})`);
        }
        
        return bestMatch;
    }

    /**
     * Global missing files'tan test case'leri al
     */
    async fetchGlobalMissingFiles() {
        try {
            console.log('üîç Global missing files listesi alƒ±nƒ±yor...');
            const response = await axios.get(`${this.apiUrl}/api/playlistsong/global-missing`);
            
            if (response.data.success || response.data.total_missing_files) {
                console.log(`‚úÖ ${response.data.total_missing_files} eksik dosya bulundu`);
                return response.data.missing_files;
            } else {
                throw new Error('Global missing files alƒ±namadƒ±');
            }
        } catch (error) {
            console.error('‚ùå Global missing files hatasƒ±:', error.message);
            return [];
        }
    }

    /**
     * Dosyayƒ± kategorize et
     */
    categorizeFile(filePath) {
        const fileName = path.basename(filePath, path.extname(filePath));
        const lowerName = fileName.toLowerCase();
        
        // Remix kontrol√º
        if (lowerName.includes('remix') || lowerName.includes('mix)')) {
            return 'remix';
        }
        
        // Sanat√ßƒ± - Ba≈ülƒ±k formatƒ±
        if (fileName.includes(' - ')) {
            return 'artistTitle';
        }
        
        // Parantez i√ßinde ek bilgi
        if (fileName.includes('(') && fileName.includes(')')) {
            return 'withParentheses';
        }
        
        // Tek kelime
        const words = fileName.split(/[\s\-_]+/).filter(w => w.length > 2);
        if (words.length === 1) {
            return 'singleWord';
        }
        
        return 'standard';
    }

    /**
     * Global missing files'tan test case'leri olu≈ütur
     */
    async defineTestCasesFromGlobal(maxTests = 50) {
        const missingFiles = await this.fetchGlobalMissingFiles();
        if (missingFiles.length === 0) {
            console.log('‚ùå Eksik dosya bulunamadƒ±, manuel test case\'leri kullanƒ±lƒ±yor');
            this.defineManualTestCases();
            return;
        }

        // Kategorilere ayƒ±r
        const categories = {};
        missingFiles.forEach(file => {
            const category = this.categorizeFile(file.originalPath);
            if (!categories[category]) {
                categories[category] = [];
            }
            categories[category].push(file);
        });

        console.log('\nüìÇ DOSYA KATEGORƒ∞LERƒ∞:');
        Object.keys(categories).forEach(cat => {
            console.log(`   ${cat}: ${categories[cat].length} dosya`);
        });

        // Her kategoriden e≈üit sayƒ±da test al
        this.tests = [];
        const testsPerCategory = Math.floor(maxTests / Object.keys(categories).length);

        Object.keys(categories).forEach(category => {
            const categoryFiles = categories[category];
            const testCount = Math.min(testsPerCategory, categoryFiles.length);
            
            // Rastgele se√ß ama √ße≈üitlilik i√ßin farklƒ± playlist'lerden al
            const selectedFiles = this.diverseSelection(categoryFiles, testCount);
            
            selectedFiles.forEach((file, index) => {
                const fileName = path.basename(file.originalPath);
                const testCase = {
                    name: `${category} - ${fileName.substring(0, 40)}${fileName.length > 40 ? '...' : ''}`,
                    searchPath: file.originalPath,
                    category: category,
                    playlistName: file.playlistName,
                    expectation: this.getExpectationForCategory(category),
                    minSimilarity: this.getMinSimilarityForCategory(category)
                };

                // Kategori √∂zel beklentiler
                if (category === 'remix') {
                    testCase.shouldNotBeFirst = 'remix';
                    testCase.expectation += ' - Remix dosyalar son sƒ±rada olmalƒ±';
                }

                if (category === 'artistTitle') {
                    testCase.expectation += ' - Sanat√ßƒ±-Ba≈ülƒ±k formatƒ± iyi e≈üle≈ümeli';
                }

                this.tests.push(testCase);
            });
        });

        console.log(`\n‚úÖ ${this.tests.length} test case olu≈üturuldu`);
    }

    /**
     * √áe≈üitli playlist'lerden se√ßim yap
     */
    diverseSelection(files, count) {
        // Playlist'lere g√∂re grupla
        const byPlaylist = {};
        files.forEach(file => {
            if (!byPlaylist[file.playlistName]) {
                byPlaylist[file.playlistName] = [];
            }
            byPlaylist[file.playlistName].push(file);
        });

        const selected = [];
        const playlists = Object.keys(byPlaylist);
        
        for (let i = 0; i < count; i++) {
            const playlistIndex = i % playlists.length;
            const playlist = playlists[playlistIndex];
            const playlistFiles = byPlaylist[playlist];
            
            if (playlistFiles.length > 0) {
                const randomIndex = Math.floor(Math.random() * playlistFiles.length);
                selected.push(playlistFiles.splice(randomIndex, 1)[0]);
            }
        }

        return selected;
    }

    /**
     * Kategori i√ßin beklenti tanƒ±mla
     */
    getExpectationForCategory(category) {
        const expectations = {
            'remix': 'Remix dosyasƒ± benzer orijinal dosya bulmalƒ±',
            'artistTitle': 'Sanat√ßƒ±-ba≈ülƒ±k formatƒ±nda e≈üle≈üme bulmalƒ±',
            'withParentheses': 'Parantez i√ßerikli dosya i√ßin temiz e≈üle≈üme bulmalƒ±',
            'singleWord': 'Tek kelimelik dosya i√ßin e≈üle≈üme bulmalƒ±',
            'standard': 'Standart dosya i√ßin e≈üle≈üme bulmalƒ±'
        };
        return expectations[category] || 'E≈üle≈üme bulmalƒ±';
    }

    /**
     * Kategori i√ßin minimum benzerlik
     */
    getMinSimilarityForCategory(category) {
        const minimums = {
            'remix': 0.4,
            'artistTitle': 0.5,
            'withParentheses': 0.3,
            'singleWord': 0.4,
            'standard': 0.3
        };
        return minimums[category] || 0.3;
    }

    /**
     * Manuel test case'leri (fallback)
     */
    defineManualTestCases() {
        this.tests = [
            {
                name: "Mahsun Kƒ±rmƒ±zƒ±g√ºl - Orijinal vs Remix",
                searchPath: "/Users/koray/Music/KorayMusics/Video2019/Mahsun Kƒ±rmƒ±zƒ±g√ºl - Sarƒ± Sarƒ±.m4a",
                expectation: "Orijinal dosyalar remix'lerden √∂nce gelmeli",
                expectedFirstMatch: "Sarƒ± Sarƒ± - Mahsun Kƒ±rmƒ±zƒ±g√ºl",
                shouldNotBeFirst: "remix",
                category: "manual"
            },
            {
                name: "Basit Dosya ƒ∞smi - Up",
                searchPath: "/Users/koray/Documents/VirtualDJ/Cache/CloudDrive/Up (4).m4a",
                expectation: "Basit isimli dosya bulunmalƒ±",
                expectedPattern: "Up.m4a",
                minSimilarity: 0.5,
                category: "manual"
            },
            {
                name: "Temperature Test",
                searchPath: "/Users/koray/Documents/VirtualDJ/Cache/CloudDrive/Temperature (4).m4a",
                expectation: "Temperature dosyasƒ± bulunmalƒ±",
                expectedPattern: "Temperature.m4a",
                minSimilarity: 0.6,
                category: "manual"
            },
            {
                name: "T√ºrk√ße Karakter - Ah Canƒ±m",
                searchPath: "/Users/koray/Documents/VirtualDJ/Cache/CloudDrive/Ah Canƒ±m Vah Canƒ±m.m4a",
                expectation: "T√ºrk√ße karakterler doƒüru √ßalƒ±≈ümalƒ±",
                expectedPattern: "Ah Canƒ±m",
                minSimilarity: 0.5,
                category: "manual"
            }
        ];
    }

    /**
     * Tek test √ßalƒ±≈ütƒ±r - API vs Manuel kar≈üƒ±la≈ütƒ±rmasƒ± ile
     */
    async runSingleTest(testCase) {
        try {
            console.log(`\nüß™ ${testCase.name}`);
            console.log(`   Arama: ${path.basename(testCase.searchPath)}`);
            console.log(`   Beklenti: ${testCase.expectation}`);

            // 1. API sonucunu al
            const response = await axios.post(`${this.apiUrl}/api/search/files`, {
                paths: [testCase.searchPath],
                options: {
                    limit: 5,
                    threshold: 0.01
                }
            });

            if (response.data.status !== 'success' || !response.data.data || !response.data.data[0]) {
                return {
                    ...testCase,
                    status: 'FAIL',
                    error: `API yanƒ±tƒ± alƒ±namadƒ± - Status: ${response.data.status}`,
                    actualResult: null
                };
            }

            const apiResult = response.data.data[0];
            const apiMatches = apiResult.matches || [];

            // 2. Manuel en iyi e≈üle≈ümeyi bul
            const manualBest = await this.findBestManualMatch(testCase.searchPath, 0.01);

            let testResult = {
                ...testCase,
                status: 'UNKNOWN',
                actualResult: {
                    found: apiResult.found,
                    topMatch: apiMatches.length > 0 ? path.parse(apiMatches[0].path).name : 'Yok',
                    topSimilarity: apiMatches.length > 0 ? apiMatches[0].similarity : 0,
                    allMatches: apiMatches.slice(0, 3).map(m => ({
                        name: path.basename(m.path),
                        similarity: m.similarity.toFixed(4)
                    }))
                },
                manualResult: manualBest ? {
                    topMatch: path.parse(manualBest.path).name,
                    similarity: manualBest.similarity.toFixed(4)
                } : null,
                algorithmEfficiency: null
            };

            // 3. API vs Manuel kar≈üƒ±la≈ütƒ±rmasƒ±
            if (manualBest && apiMatches.length > 0) {
                const apiSimilarity = apiMatches[0].similarity;
                const manualSimilarity = manualBest.similarity;
                
                testResult.algorithmEfficiency = {
                    apiFound: apiSimilarity.toFixed(4),
                    manualBest: manualSimilarity.toFixed(4),
                    difference: (apiSimilarity - manualSimilarity).toFixed(4),
                    isOptimal: apiSimilarity >= manualSimilarity * 0.95 // %95 verimlilik
                };
                
                console.log(`   üìä API: ${apiSimilarity.toFixed(4)} vs Manuel: ${manualSimilarity.toFixed(4)} (Fark: ${testResult.algorithmEfficiency.difference})`);
                
                if (!testResult.algorithmEfficiency.isOptimal) {
                    console.log(`   ‚ö†Ô∏è API daha iyi sonucu ka√ßƒ±rƒ±yor! Manuel: ${path.basename(manualBest.path)}`);
                }
            }

            // 4. Ana test kriteri: Algoritma verimliliƒüi
            if (testResult.algorithmEfficiency) {
                if (testResult.algorithmEfficiency.isOptimal) {
                    testResult.status = 'PASS';
                    testResult.message = `‚úÖ Algoritma optimal: API=${testResult.algorithmEfficiency.apiFound}, Manuel=${testResult.algorithmEfficiency.manualBest}`;
                } else {
                    testResult.status = 'FAIL';
                    testResult.message = `‚ùå Algoritma suboptimal: API=${testResult.algorithmEfficiency.apiFound}, Manuel=${testResult.algorithmEfficiency.manualBest} (Fark: ${testResult.algorithmEfficiency.difference})`;
                }
            }

            // 5. Ek test kriterleri (sadece algoritma optimal deƒüilse)
            if (testResult.status === 'UNKNOWN') {
                if (testCase.expectedFirstMatch) {
                    // ƒ∞lk e≈üle≈üme beklenen dosya mƒ±?
                    if (apiMatches.length > 0 && (apiMatches[0].path.includes(testCase.expectedFirstMatch) || testResult.actualResult.topMatch.includes(testCase.expectedFirstMatch))) {
                        testResult.status = 'PASS';
                        testResult.message = `‚úÖ ƒ∞lk e≈üle≈üme doƒüru: ${testResult.actualResult.topMatch}`;
                    } else {
                        testResult.status = 'FAIL';
                        testResult.message = `‚ùå ƒ∞lk e≈üle≈üme yanlƒ±≈ü. Beklenen: ${testCase.expectedFirstMatch}, Ger√ßek: ${testResult.actualResult.topMatch}`;
                    }
                }

                if (testCase.shouldNotBeFirst && testResult.status === 'UNKNOWN') {
                    // ƒ∞lk e≈üle≈üme bu pattern'i i√ßermemeli
                    if (apiMatches.length > 0 && apiMatches[0].path.toLowerCase().includes(testCase.shouldNotBeFirst.toLowerCase())) {
                        testResult.status = 'FAIL';
                        testResult.message = `‚ùå ƒ∞lk e≈üle≈üme '${testCase.shouldNotBeFirst}' i√ßeriyor: ${testResult.actualResult.topMatch}`;
                    } else {
                        testResult.status = 'PASS';
                        testResult.message = `‚úÖ ƒ∞lk e≈üle≈üme '${testCase.shouldNotBeFirst}' i√ßermiyor`;
                    }
                }

                if (testCase.minSimilarity && testResult.status === 'UNKNOWN') {
                    // Minimum benzerlik kontrol√º
                    if (apiMatches.length > 0 && apiMatches[0].similarity >= testCase.minSimilarity) {
                        testResult.status = 'PASS';
                        testResult.message = `‚úÖ Minimum benzerlik saƒülandƒ±: ${apiMatches[0].similarity.toFixed(4)} >= ${testCase.minSimilarity}`;
                    } else {
                        testResult.status = 'FAIL';
                        testResult.message = `‚ùå Minimum benzerlik saƒülanamadƒ±: ${apiMatches[0]?.similarity.toFixed(4) || 0} < ${testCase.minSimilarity}`;
                    }
                }

                // Eƒüer hala belirsizse, genel kontrol
                if (testResult.status === 'UNKNOWN') {
                    if (apiResult.found && apiMatches.length > 0) {
                        testResult.status = 'PASS';
                        testResult.message = `‚úÖ Dosya bulundu: ${testResult.actualResult.topMatch}`;
                    } else {
                        testResult.status = 'FAIL';
                        testResult.message = `‚ùå Dosya bulunamadƒ±`;
                    }
                }
            }

            console.log(`   ${testResult.message || 'Test tamamlandƒ±'}`);
            if (testResult.actualResult && testResult.actualResult.topSimilarity) {
                console.log(`   En iyi e≈üle≈üme: ${testResult.actualResult.topMatch} (${testResult.actualResult.topSimilarity.toFixed(4)})`);
            } else {
                console.log(`   Sonu√ß: E≈üle≈üme bulunamadƒ±`);
            }

            return testResult;

        } catch (error) {
            console.log(`   ‚ùå Test hatasƒ±: ${error.message}`);
            return {
                ...testCase,
                status: 'ERROR',
                error: error.message,
                actualResult: null
            };
        }
    }

    /**
     * T√ºm testleri √ßalƒ±≈ütƒ±r
     */
    async runAllTests(maxTests = 30) {
        console.log('üß™ BENZERLƒ∞K ALGORƒ∞TMASI TEST Sƒ∞STEMƒ∞ - GLOBAL MISSING FILES');
        console.log('='.repeat(60));

        await this.defineTestCasesFromGlobal(maxTests);
        this.results = [];

        console.log(`\nüöÄ ${this.tests.length} test √ßalƒ±≈ütƒ±rƒ±lƒ±yor...\n`);

        for (let i = 0; i < this.tests.length; i++) {
            const testCase = this.tests[i];
            console.log(`[${i + 1}/${this.tests.length}] ${testCase.category.toUpperCase()}`);
            
            const result = await this.runSingleTest(testCase);
            this.results.push(result);
            
            // Progress g√∂ster
            if ((i + 1) % 5 === 0) {
                const completed = i + 1;
                const total = this.tests.length;
                const percentage = ((completed / total) * 100).toFixed(1);
                console.log(`\nüìä ƒ∞lerleme: ${completed}/${total} (%${percentage})\n`);
            }
            
            // Testler arasƒ± kƒ±sa bekleme
            await new Promise(resolve => setTimeout(resolve, 300));
        }

        this.printSummary();
        this.printCategoryAnalysis();
        return this.results;
    }

    /**
     * Kategori bazlƒ± analiz yazdƒ±r
     */
    printCategoryAnalysis() {
        console.log('\nüìà KATEGORƒ∞ BAZLI ANALƒ∞Z');
        console.log('='.repeat(40));

        const categoryStats = {};
        this.results.forEach(result => {
            const category = result.category;
            if (!categoryStats[category]) {
                categoryStats[category] = {
                    total: 0,
                    passed: 0,
                    failed: 0,
                    avgSimilarity: 0,
                    similarities: []
                };
            }
            
            categoryStats[category].total++;
            if (result.status === 'PASS') {
                categoryStats[category].passed++;
            } else {
                categoryStats[category].failed++;
            }
            
            if (result.actualResult && result.actualResult.topSimilarity) {
                categoryStats[category].similarities.push(result.actualResult.topSimilarity);
            }
        });

        // Ortalama benzerlik hesapla
        Object.keys(categoryStats).forEach(category => {
            const stats = categoryStats[category];
            if (stats.similarities.length > 0) {
                stats.avgSimilarity = stats.similarities.reduce((a, b) => a + b, 0) / stats.similarities.length;
            }
        });

        // Kategori istatistiklerini yazdƒ±r
        Object.keys(categoryStats).sort().forEach(category => {
            const stats = categoryStats[category];
            const successRate = ((stats.passed / stats.total) * 100).toFixed(1);
            
            console.log(`\nüìÇ ${category.toUpperCase()}`);
            console.log(`   Toplam: ${stats.total}`);
            console.log(`   Ba≈üarƒ±lƒ±: ${stats.passed} (%${successRate})`);
            console.log(`   Ba≈üarƒ±sƒ±z: ${stats.failed}`);
            console.log(`   Ortalama Benzerlik: ${stats.avgSimilarity.toFixed(4)}`);
            
            // Kategori √∂zel √∂neriler
            if (successRate < 50) {
                console.log(`   üî¥ Dƒ∞KKAT: Bu kategori i√ßin algoritma iyile≈ütirmesi gerekli!`);
            } else if (successRate < 70) {
                console.log(`   üü° UYARI: Bu kategoride iyile≈ütirme potansiyeli var`);
            } else {
                console.log(`   ‚úÖ Bu kategori iyi √ßalƒ±≈üƒ±yor`);
            }
        });
    }

    /**
     * Test √∂zeti yazdƒ±r
     */
    printSummary() {
        console.log('\nüìä TEST √ñZETƒ∞');
        console.log('='.repeat(30));

        const passed = this.results.filter(r => r.status === 'PASS').length;
        const failed = this.results.filter(r => r.status === 'FAIL').length;
        const errors = this.results.filter(r => r.status === 'ERROR').length;

        console.log(`‚úÖ Ba≈üarƒ±lƒ±: ${passed}`);
        console.log(`‚ùå Ba≈üarƒ±sƒ±z: ${failed}`);
        console.log(`üî• Hata: ${errors}`);
        console.log(`üìà Ba≈üarƒ± Oranƒ±: %${((passed / this.results.length) * 100).toFixed(1)}`);

        if (failed > 0) {
            console.log('\n‚ùå BA≈ûARISIZ TESTLER:');
            this.results
                .filter(r => r.status === 'FAIL')
                .forEach(r => {
                    console.log(`   ‚Ä¢ ${r.name}: ${r.message}`);
                });
        }

        if (errors > 0) {
            console.log('\nüî• HATALI TESTLER:');
            this.results
                .filter(r => r.status === 'ERROR')
                .forEach(r => {
                    console.log(`   ‚Ä¢ ${r.name}: ${r.error}`);
                });
        }

        console.log('\nüéØ GENEL DEƒûERLENDƒ∞RME:');
        if (passed === this.results.length) {
            console.log('   üéâ T√ºm testler ba≈üarƒ±lƒ±! Algoritma d√ºzg√ºn √ßalƒ±≈üƒ±yor.');
        } else if (passed >= this.results.length * 0.8) {
            console.log('   ‚úÖ Testlerin √ßoƒüu ba≈üarƒ±lƒ±. K√º√ß√ºk iyile≈ütirmeler gerekebilir.');
        } else {
            console.log('   ‚ö†Ô∏è √áok sayƒ±da test ba≈üarƒ±sƒ±z. Algoritma g√∂zden ge√ßirilmeli.');
        }
    }

    /**
     * Belirli bir test √ßalƒ±≈ütƒ±r
     */
    async runSpecificTest(testName) {
        this.defineTestCases();
        const testCase = this.tests.find(t => t.name.toLowerCase().includes(testName.toLowerCase()));
        
        if (!testCase) {
            console.log(`‚ùå Test bulunamadƒ±: ${testName}`);
            console.log('Mevcut testler:');
            this.tests.forEach(t => console.log(`  ‚Ä¢ ${t.name}`));
            return null;
        }

        return await this.runSingleTest(testCase);
    }
}

// CLI kullanƒ±mƒ±
if (require.main === module) {
    const tester = new SimilarityFixTester();
    
    const command = process.argv[2];
    const maxTests = process.argv[3] ? parseInt(process.argv[3]) : 30;
    
    console.log('üéØ GLOBAL MISSING FILES TEST Sƒ∞STEMƒ∞');
    console.log(`   Komut: ${command || 'all'}`);
    console.log(`   Max Test: ${maxTests}`);
    console.log('');
    
    async function main() {
        try {
            if (command === 'all' || !command) {
                await tester.runAllTests(maxTests);
            } else if (command === 'manual') {
                tester.defineManualTestCases();
                tester.results = [];
                for (const testCase of tester.tests) {
                    const result = await tester.runSingleTest(testCase);
                    tester.results.push(result);
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                tester.printSummary();
            } else {
                await tester.runSpecificTest(command);
            }
        } catch (error) {
            console.error('‚ùå Fatal error:', error);
        }
    }
    
    main();
}

module.exports = SimilarityFixTester;

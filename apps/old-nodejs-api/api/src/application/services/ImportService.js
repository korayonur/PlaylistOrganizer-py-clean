'use strict';

const fs = require('fs');
const path = require('path');
const { getDatabaseManager } = require('../../infrastructure/persistence/DatabaseManager');
const config = require('../../shared/config');
const WordIndexService = require('./WordIndexService');

/**
 * Import Service - Clean Architecture
 */
class ImportService {
    constructor(db, wordIndexService) {
        this.db = db;
        this.wordIndexService = wordIndexService;
        this.config = config;
    }

    /**
     * Import √∂ncesi tablolarƒ± temizle
     */
    clearImportTables() {
        try {
            const timestamp = new Date().toISOString();
            console.log(`[${timestamp}] [INFO] [IMPORT] [CLEAR] Tablolar temizleniyor...`);
            
            // Import √∂ncesi tablo sayƒ±larƒ±nƒ± logla
            const musicFilesCount = this.db.prepare('SELECT COUNT(*) as count FROM music_files').get().count;
            const tracksCount = this.db.prepare('SELECT COUNT(*) as count FROM tracks').get().count;
            const sessionsCount = this.db.prepare('SELECT COUNT(*) as count FROM import_sessions').get().count;
            
            // temp_tracks tablosu hen√ºz olu≈üturulmamƒ±≈ü olabilir
            let tempTracksCount = 0;
            try {
                tempTracksCount = this.db.prepare('SELECT COUNT(*) as count FROM temp_tracks').get().count;
            } catch (error) {
                tempTracksCount = 0; // Tablo yok, 0 olarak kabul et
            }
            
            console.log(`[${timestamp}] [DEBUG] [IMPORT] [CLEAR] √ñncesi: music_files=${musicFilesCount}, tracks=${tracksCount}, temp_tracks=${tempTracksCount}, sessions=${sessionsCount}`);
            
            // ‚ö†Ô∏è √ñNEMLI: Foreign key constraint'leri ge√ßici olarak kapat
            this.db.exec('PRAGMA foreign_keys = OFF');
            console.log(`[${timestamp}] [DEBUG] [IMPORT] [CLEAR] üîì Foreign keys kapatƒ±ldƒ±`);
            
            // Temp tablolarƒ± import sƒ±rasƒ±nda olu≈üturulacak, burada temizlemeye gerek yok
            
            // YENƒ∞ YAPI: √ñnce ili≈üki tablosunu temizle
            this.db.prepare('DELETE FROM playlist_tracks').run();
            console.log(`[${timestamp}] [DEBUG] [IMPORT] [CLEAR] ‚úÖ playlist_tracks temizlendi`);
            
            // Sonra playlist'leri temizle
            this.db.prepare('DELETE FROM playlists').run();
            console.log(`[${timestamp}] [DEBUG] [IMPORT] [CLEAR] ‚úÖ playlists temizlendi`);
            
            // Tracks'leri sil
            this.db.prepare('DELETE FROM tracks').run();
            console.log(`[${timestamp}] [DEBUG] [IMPORT] [CLEAR] ‚úÖ tracks temizlendi`);
            
            // track_words temizle
            this.db.prepare('DELETE FROM track_words').run();
            console.log(`[${timestamp}] [DEBUG] [IMPORT] [CLEAR] ‚úÖ track_words temizlendi`);
            
            // music_files'ƒ± sil
            this.db.prepare('DELETE FROM music_files').run();
            console.log(`[${timestamp}] [DEBUG] [IMPORT] [CLEAR] ‚úÖ music_files temizlendi`);
            
            // music_words temizle
            this.db.prepare('DELETE FROM music_words').run();
            console.log(`[${timestamp}] [DEBUG] [IMPORT] [CLEAR] ‚úÖ music_words temizlendi`);
            
            // ‚ö†Ô∏è UYARI: import_sessions TEMƒ∞ZLENMEZ - import ge√ßmi≈üi korunur!
            console.log(`[${timestamp}] [DEBUG] [IMPORT] [CLEAR] ‚ÑπÔ∏è  import_sessions korundu (ge√ßmi≈ü kayƒ±tlarƒ±)`);
            
            // Foreign key constraint'leri tekrar a√ß
            this.db.exec('PRAGMA foreign_keys = ON');
            console.log(`[${timestamp}] [DEBUG] [IMPORT] [CLEAR] üîí Foreign keys a√ßƒ±ldƒ±`);
            
            console.log(`[${timestamp}] [INFO] [IMPORT] [CLEAR] üéâ T√ºm tablolar temizlendi`);
        } catch (error) {
            const timestamp = new Date().toISOString();
            console.error(`[${timestamp}] [ERROR] [IMPORT] [CLEAR] ‚ùå Tablo temizleme hatasƒ±: ${error.message}`);
            // Foreign key'leri tekrar a√ß
            try {
                this.db.exec('PRAGMA foreign_keys = ON');
            } catch (fkError) {
                // Ignore
            }
            throw error;
        }
    }

    /**
     * VirtualDJ klas√∂r√ºn√º tara ve import et
     * @param {Function} progressCallback - Progress callback (opsiyonel)
     * @returns {Promise<Object>} Import sonucu
     */
    async scanAndImport(progressCallback = null) {
        const startTime = Date.now();
        const timestamp = new Date().toISOString();
        
        // Progress helper
        const reportProgress = (stage, current, total, message = '') => {
            if (progressCallback) {
                progressCallback({ stage, current, total, percentage: Math.round((current / total) * 100), message });
            }
        };
        
        // Config'den path'leri al
        const importPaths = this.config.getImportPaths();
        const virtualDJPath = importPaths.virtualDJ;
        const musicPath = importPaths.music;
        
        try {
            console.log(`[${timestamp}] [INFO] [IMPORT] [START] Import ba≈ülatƒ±lƒ±yor: VirtualDJ + M√ºzik klas√∂rleri`);
            console.log(`[${timestamp}] [DEBUG] [IMPORT] [CONFIG] VirtualDJ="${virtualDJPath}", Music="${musicPath}"`);
            
            // 0. Import √∂ncesi tablolarƒ± temizle
            console.log(`[${timestamp}] [INFO] [IMPORT] [CLEAR] Import √∂ncesi tablolar temizleniyor...`);
            this.clearImportTables();
            
            // 1. VirtualDJ klas√∂r√ºn√º tara (playlist'ler i√ßin - M3U ve VDJFOLDER sadece burada)
            console.log(`[${timestamp}] [INFO] [IMPORT] [SCAN] VirtualDJ klas√∂r√º taranƒ±yor: ${virtualDJPath}`);
            const virtualDJResult = await this.scanDirectoryAsync(virtualDJPath);
            
            // 2. M√ºzik klas√∂r√ºn√º tara (m√ºzik dosyalarƒ± i√ßin)
            console.log(`üìÅ M√ºzik klas√∂r√º taranƒ±yor: ${musicPath}`);
            const musicResult = await this.scanDirectoryAsync(musicPath);
            
            // 3. Sonu√ßlarƒ± birle≈ütir
            const scanResult = {
                musicFiles: musicResult.musicFiles,
                tracks: virtualDJResult.tracks,
                playlistFiles: virtualDJResult.playlistFiles || []
            };
            
            console.log(`üîç DEBUG: virtualDJResult.tracks.length = ${virtualDJResult.tracks.length}`);
            console.log(`üîç DEBUG: musicResult.musicFiles.length = ${musicResult.musicFiles.length}`);
            console.log(`üîç DEBUG: virtualDJResult.playlistFiles.length = ${(virtualDJResult.playlistFiles || []).length}`);
            
            // M3U ve VDJFOLDER dosya sayƒ±larƒ±nƒ± ayrƒ± ayrƒ± say
            const m3uCount = virtualDJResult.tracks.filter(track => track.source === 'm3u').length;
            const vdjfolderCount = virtualDJResult.tracks.filter(track => track.source === 'vdjfolder').length;
            console.log(`üìä Playlist dosya t√ºrleri: M3U=${m3uCount}, VDJFOLDER=${vdjfolderCount}`);
            
            const totalFiles = scanResult.musicFiles.length + scanResult.tracks.length;
            console.log(`üìä Tarama sonucu: ${scanResult.musicFiles.length} m√ºzik dosyasƒ±, ${scanResult.tracks.length} track bulundu`);

            // 2. Import session olu≈ütur
            const sessionId = this.createSession(virtualDJPath, totalFiles);
            console.log(`‚úÖ Session olu≈üturuldu: ID=${sessionId}`);

            let added = 0;
            let skipped = 0;
            let errors = 0;
            
            // Detaylƒ± tracking i√ßin sayƒ±larƒ± sakla
            let musicFilesAdded = 0;
            let tracksAdded = 0;
            let playlistsAdded = 0;

                   // 3. M√ºzik dosyalarƒ±nƒ± asenkron toplu import et
                   console.log(`üéµ M√ºzik dosyalarƒ± asenkron toplu import ediliyor... (${scanResult.musicFiles.length} dosya)`);
                   
                   if (scanResult.musicFiles.length > 0) {
                       const result = await this.bulkAddFilesAsync(scanResult.musicFiles);
                       added += result.added;
                       skipped += result.skipped;
                       errors += result.errors;
                       // Mevcut toplam music_files sayƒ±sƒ±nƒ± al (eklenen deƒüil)
                       musicFilesAdded = this.db.prepare('SELECT COUNT(*) as count FROM music_files').get().count;
                       console.log(`‚úÖ M√ºzik dosyalarƒ± asenkron toplu import tamamlandƒ±: ${result.added} eklendi, ${result.skipped} atlandƒ±, ${result.errors} hata`);
                   }

                   // 3.5. YENƒ∞: Playlist'leri import et
                   console.log(`üìÅ Playlist'ler import ediliyor... (${scanResult.playlistFiles.length} playlist)`);
                   
                   if (scanResult.playlistFiles.length > 0) {
                       const playlists = await this.bulkAddPlaylistsAsync(scanResult.playlistFiles);
                       // Mevcut toplam playlist sayƒ±sƒ±nƒ± al (eklenen deƒüil)
                       playlistsAdded = this.db.prepare('SELECT COUNT(*) as count FROM playlists').get().count;
                       console.log(`‚úÖ ${playlists.length} playlist eklendi`);
                   }

                   // 4. Tracks'leri asenkron toplu import et
                   console.log(`üéß Tracks asenkron toplu import ediliyor... (${scanResult.tracks.length} track)`);
                   
                   if (scanResult.tracks.length > 0) {
                       const result = await this.bulkAddTracksAsync(scanResult.tracks);
                       added += result.added;
                       skipped += result.skipped;
                       errors += result.errors;
                       // Mevcut toplam track sayƒ±sƒ±nƒ± al (eklenen deƒüil)
                       tracksAdded = this.db.prepare('SELECT COUNT(*) as count FROM tracks').get().count;
                       console.log(`‚úÖ Tracks asenkron toplu import tamamlandƒ±: ${result.added} eklendi, ${result.skipped} atlandƒ±, ${result.errors} hata`);
                   }

            // 5. Session'ƒ± g√ºncelle - DETAYLI
            // Index sayƒ±larƒ±nƒ± hesapla
            const trackWordsCount = this.db.prepare('SELECT COUNT(*) as count FROM track_words').get().count;
            const musicWordsCount = this.db.prepare('SELECT COUNT(*) as count FROM music_words').get().count;
            const playlistTracksCount = this.db.prepare('SELECT COUNT(*) as count FROM playlist_tracks').get().count;
            const totalIndexCount = trackWordsCount + musicWordsCount + playlistTracksCount;
            
            // Playlist track count'larƒ±nƒ± g√ºncelle
            await this.updatePlaylistTrackCounts();
            
            this.updateSession(sessionId, {
                operation_type: 'import',
                processed_files: totalFiles,
                added_files: added,
                skipped_files: skipped,
                error_files: errors,
                
                // YENƒ∞ DETAYLAR:
                music_files_count: musicFilesAdded,
                tracks_count: tracksAdded,
                playlists_count: playlistsAdded,
                index_count: totalIndexCount
            });

            console.log(`üéâ Import tamamlandƒ±! Toplam: ${totalFiles}, Eklenen: ${added}, Atlanan: ${skipped}, Hata: ${errors}`);

            return {
                success: true,
                data: {
                    sessionId,
                    path: virtualDJPath,
                    totalFiles: totalFiles,
                    added,
                    skipped,
                    errors,
                    isComplete: true
                },
                message: 'VirtualDJ import ba≈üarƒ±yla tamamlandƒ±'
            };

        } catch (error) {
            console.log(`üí• Import hatasƒ±: ${error.message}`);
            console.error(`üí• Import hatasƒ±: ${error.message}`);
            return {
                success: false,
                message: 'Import hatasƒ±',
                error: error.message
            };
        }
    }

    /**
     * Klas√∂r√º asenkron olarak tara ve dosyalarƒ± bul (batch processing ile)
     * @param {string} dirPath - Taranacak klas√∂r yolu
     * @returns {Promise<Object>} Tarama sonucu
     */
    async scanDirectoryAsync(dirPath) {
        const timestamp = new Date().toISOString();
        console.log(`[${timestamp}] [INFO] [SCAN] [ASYNC] Klas√∂r taranƒ±yor: ${dirPath}`);
        
        const result = {
            musicFiles: [],
            tracks: [],
            playlistFiles: []  // YENƒ∞: Playlist dosya listesi
        };
        
        const isVirtualDJFolder = dirPath.includes('VirtualDJ');
        const BATCH_SIZE = 100; // Her batch'te 100 dosya i≈üle
        
        try {
            const items = fs.readdirSync(dirPath);
            console.log(`[${timestamp}] [DEBUG] [SCAN] [ASYNC] ${items.length} dosya bulundu, batch processing ba≈ülatƒ±lƒ±yor...`);
            
            // Dosyalarƒ± batch'ler halinde i≈üle
            for (let i = 0; i < items.length; i += BATCH_SIZE) {
                const batch = items.slice(i, i + BATCH_SIZE);
                console.log(`[${timestamp}] [DEBUG] [SCAN] [BATCH] Batch ${Math.floor(i/BATCH_SIZE) + 1}/${Math.ceil(items.length/BATCH_SIZE)} i≈üleniyor (${batch.length} dosya)`);
                
                // Batch'i i≈üle
                for (const item of batch) {
                    const itemPath = path.join(dirPath, item);
                    
                    // Dƒ±≈ülanacak klas√∂rleri kontrol et
                    if (config.isExcludedPath(itemPath)) {
                        console.log(`[${timestamp}] [SKIP] [EXCLUDED] Dƒ±≈ülanan klas√∂r: ${itemPath}`);
                        continue;
                    }
                    
                    const stats = fs.statSync(itemPath);
                    
                    if (stats.isDirectory()) {
                        // Alt klas√∂r√º recursive olarak tara
                        const subResult = await this.scanDirectoryAsync(itemPath);
                        result.musicFiles.push(...subResult.musicFiles);
                        result.tracks.push(...subResult.tracks);
                        if (subResult.playlistFiles) result.playlistFiles.push(...subResult.playlistFiles);
                    } else if (this.isMediaFile(itemPath)) {
                        result.musicFiles.push({
                            path: itemPath,
                            fileName: item,
                            extension: path.extname(item).toLowerCase(),
                            size: stats.size,
                            modified: stats.mtime,
                            created: stats.birthtime
                        });
                    } else if (this.isPlaylistFile(itemPath)) {
                        // ‚ö†Ô∏è Playlist dosyalarƒ±nƒ± SADECE VirtualDJ klas√∂r√ºnde tara
                        if (isVirtualDJFolder) {
                            console.log(`üîç Playlist dosyasƒ± bulundu: ${path.basename(itemPath)}`);
                            
                            // YENƒ∞: Playlist dosya bilgisini topla (normalizasyon i√ßin)
                            if (!result.playlistFiles) result.playlistFiles = [];
                            result.playlistFiles.push({
                                path: itemPath,
                                extension: path.extname(itemPath).toLowerCase()
                            });
                            
                            const playlistTracks = this.parsePlaylistFile(itemPath);
                            result.tracks.push(...playlistTracks);
                        } else {
                            console.log(`‚ö†Ô∏è Playlist dosyasƒ± atlandƒ± (VirtualDJ dƒ±≈üƒ±): ${itemPath}`);
                        }
                    }
                }
                
                // CPU'yu serbest bƒ±rak - diƒüer i≈ülemlerin √ßalƒ±≈ümasƒ±na izin ver
                if (i + BATCH_SIZE < items.length) {
                    await new Promise(resolve => setImmediate(resolve));
                }
            }
            
        } catch (error) {
            console.error(`‚ùå Klas√∂r tarama hatasƒ±: ${dirPath} - ${error.message}`);
        }
        
        console.log(`üìä Klas√∂r tarama tamamlandƒ±: ${dirPath} - ${result.musicFiles.length} m√ºzik dosyasƒ±, ${result.tracks.length} track`);
        return result;
    }

    /**
     * Klas√∂r√º tara
     * @param {string} dirPath - Klas√∂r yolu
     * @returns {Object} Dosya listesi (m√ºzik dosyalarƒ± ve tracks ayrƒ±)
     */
    scanDirectory(dirPath) {
        const result = {
            musicFiles: [],
            tracks: []
        };
        
        // VirtualDJ klas√∂r√º m√º kontrol et
        const importPaths = this.config.getImportPaths();
        const isVirtualDJFolder = dirPath.startsWith(importPaths.virtualDJ);
        
        try {
            const items = fs.readdirSync(dirPath);
            
            for (const item of items) {
                const itemPath = path.join(dirPath, item);
                const stats = fs.statSync(itemPath);
                
                if (stats.isDirectory()) {
                    // Alt klas√∂rleri de tara
                    const subResult = this.scanDirectory(itemPath);
                    result.musicFiles.push(...subResult.musicFiles);
                    result.tracks.push(...subResult.tracks);
                } else if (this.isMediaFile(itemPath)) {
                    result.musicFiles.push({
                        path: itemPath,
                        fileName: item,
                        extension: path.extname(item).toLowerCase(),
                        size: stats.size,
                        modified: stats.mtime,
                        created: stats.birthtime
                    });
                } else if (this.isPlaylistFile(itemPath)) {
                    // ‚ö†Ô∏è Playlist dosyalarƒ±nƒ± SADECE VirtualDJ klas√∂r√ºnde tara
                    if (isVirtualDJFolder) {
                        console.log(`üîç Playlist dosyasƒ± bulundu: ${path.basename(itemPath)}`);
                        const playlistTracks = this.parsePlaylistFile(itemPath);
                        result.tracks.push(...playlistTracks);
                    } else {
                        console.log(`‚ö†Ô∏è Playlist dosyasƒ± atlandƒ± (VirtualDJ dƒ±≈üƒ±): ${itemPath}`);
                    }
                }
            }
        } catch (error) {
            console.error(`‚ùå Klas√∂r tarama hatasƒ±: ${dirPath} - ${error.message}`);
        }
        
        console.log(`üìä Klas√∂r tarama tamamlandƒ±: ${dirPath} - ${result.musicFiles.length} m√ºzik dosyasƒ±, ${result.tracks.length} track`);
        return result;
    }

    /**
     * Medya dosyasƒ± mƒ± kontrol et
     * @param {string} filePath - Dosya yolu
     * @returns {boolean}
     */
    isMediaFile(filePath) {
        const ext = path.extname(filePath).toLowerCase();
        return this.config.isMusicExtension(ext);
    }

    /**
     * Playlist dosyasƒ± mƒ± kontrol et
     * @param {string} filePath - Dosya yolu
     * @returns {boolean}
     */
    isPlaylistFile(filePath) {
        const ext = path.extname(filePath).toLowerCase();
        return this.config.isPlaylistExtension(ext);
    }

    /**
     * M3U dosyasƒ±nƒ± parse et
     * @param {string} filePath - M3U dosya yolu
     * @returns {Array} Track listesi
     */
    parseM3UFile(filePath) {
        try {
            const fileContent = fs.readFileSync(filePath, 'utf8');
            const lines = fileContent.split(/\r?\n/);
            const tracks = [];
            let currentMetadata = null;

            for (const rawLine of lines) {
                const line = rawLine.trim();
                if (!line) continue;

                if (line.startsWith('#EXTVDJ')) {
                    currentMetadata = this.parseExtVDJ(line);
                    continue;
                }

                if (line.toLowerCase().includes('.vdjcache')) {
                    continue;
                }

                // Tam yol kontrol√º - eƒüer tam yol deƒüilse atla
                if (!path.isAbsolute(line)) {
                    console.log(`‚ö†Ô∏è M3U'da tam yol olmayan satƒ±r atlandƒ±: ${line}`);
                    continue;
                }

                // HTML decode yap
                const decodedPath = this.htmlDecode(line);
                const normalizedName = this.normalizeFileName(path.basename(decodedPath));
                const filteredName = normalizedName; // wordSimilarity kaldƒ±rƒ±ldƒ±, direkt kullan
                tracks.push({
                    originalPath: decodedPath,
                    normalizedName: filteredName,
                    metadata: currentMetadata
                });
                currentMetadata = null;
            }

            return tracks;
        } catch (error) {
            console.error(`‚ùå M3U parse hatasƒ±: ${filePath} - ${error.message}`);
            return [];
        }
    }

    /**
     * VDJFOLDER dosyasƒ±nƒ± parse et (XML format)
     * @param {string} filePath - VDJFOLDER dosya yolu
     * @returns {Array} Track listesi
     */
    parseVDJFolderFile(filePath) {
        try {
            const fileContent = fs.readFileSync(filePath, 'utf8');
            const tracks = [];

            // XML'den song elementlerini √ßƒ±kar
            const songRegex = /<song[^>]*path="([^"]*)"[^>]*>/g;
            let match;

            while ((match = songRegex.exec(fileContent)) !== null) {
                let songPath = match[1];
                if (songPath && songPath.trim()) {
                    // HTML decode yap
                    songPath = this.htmlDecode(songPath);
                    
                    const normalizedName = this.normalizeFileName(path.basename(songPath));
                    const filteredName = normalizedName; // wordSimilarity kaldƒ±rƒ±ldƒ±, direkt kullan
                    tracks.push({
                        originalPath: songPath,
                        normalizedName: filteredName,
                        metadata: null
                    });
                }
            }

            return tracks;
        } catch (error) {
            console.error(`‚ùå VDJFOLDER parse hatasƒ±: ${filePath} - ${error.message}`);
            return [];
        }
    }

    /**
     * HTML decode fonksiyonu
     * @param {string} str - HTML encoded string
     * @returns {string} Decoded string
     */
    htmlDecode(str) {
        if (!str) return str;
        
        return str
            .replace(/&apos;/g, "'")
            .replace(/&quot;/g, '"')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&');
    }

    /**
     * Dosya adƒ±nƒ± normalize et - WordIndexService.normalize kullan
     * Bu sayede t√ºm sistem tek bir normalize fonksiyonu kullanƒ±r
     * @param {string} fileName - Dosya adƒ±
     * @returns {string} Normalize edilmi≈ü dosya adƒ±
     */
    normalizeFileName(fileName) {
        // WordIndexService'deki normalize fonksiyonunu kullan
        // Bu fonksiyon t√ºm d√ºnya dilleri + apostrof desteƒüi saƒülar
        return this.wordIndexService.normalize(fileName);
    }

    /**
     * Playlist track count'larƒ±nƒ± g√ºncelle
     * @returns {number} G√ºncellenen playlist sayƒ±sƒ±
     */
    async updatePlaylistTrackCounts() {
        try {
            console.log('üîÑ Playlist track countlarƒ± g√ºncelleniyor...');
            
            // playlist_tracks tablosundan ger√ßek sayƒ±larƒ± hesapla ve playlists tablosunu g√ºncelle
            const updateStmt = this.db.prepare(`
                UPDATE playlists 
                SET track_count = (
                    SELECT COUNT(*)
                    FROM playlist_tracks pt
                    WHERE pt.playlist_id = playlists.id
                ),
                updated_at = CURRENT_TIMESTAMP
                WHERE id IN (
                    SELECT DISTINCT playlist_id 
                    FROM playlist_tracks
                )
            `);

            const result = updateStmt.run();
            console.log(`‚úÖ ${result.changes} playlist track_count g√ºncellendi`);
            
            return result.changes;
        } catch (error) {
            console.error(`‚ùå Track count g√ºncelleme hatasƒ±: ${error.message}`);
            throw error;
        }
    }

    /**
     * VirtualDJ metadata'sƒ±nƒ± parse et
     * @param {string} line - EXTVDJ satƒ±rƒ±
     * @returns {Object|null} Metadata objesi
     */
    parseExtVDJ(line) {
        const metadata = {};
        const regex = /<([^>]+)>([^<]*)<\/[^>]+>/g;
        let match;

        while ((match = regex.exec(line)) !== null) {
            const key = match[1];
            let value = match[2];
            
            // HTML decode yap
            value = this.htmlDecode(value);
            
            metadata[key] = value;
        }

        return Object.keys(metadata).length > 0 ? metadata : null;
    }

    /**
     * Playlist dosyasƒ±nƒ± parse et
     * @param {string} filePath - Playlist dosya yolu
     * @returns {Array} Track listesi
     */
    parsePlaylistFile(filePath) {
        const ext = path.extname(filePath).toLowerCase();
        const tracks = [];

        if (ext === '.m3u' || ext === '.m3u8') {
            const playlistTracks = this.parseM3UFile(filePath);
            console.log(`üìÑ M3U dosyasƒ± i≈ülendi: ${path.basename(filePath)} - ${playlistTracks.length} track`);
            return playlistTracks.map(track => ({
                path: track.originalPath,
                fileName: path.basename(track.originalPath),
                fileNameOnly: path.basename(track.originalPath, path.extname(track.originalPath)),
                normalizedFileName: track.normalizedName,
                extension: path.extname(track.originalPath).toLowerCase(),
                source: 'm3u',
                source_file: filePath,
                metadata: track.metadata
            }));
        } else if (ext === '.vdjfolder') {
            const playlistTracks = this.parseVDJFolderFile(filePath);
            console.log(`üìÑ VDJFOLDER dosyasƒ± i≈ülendi: ${path.basename(filePath)} - ${playlistTracks.length} track`);
            return playlistTracks.map(track => ({
                path: track.originalPath,
                fileName: path.basename(track.originalPath),
                fileNameOnly: path.basename(track.originalPath, path.extname(track.originalPath)),
                normalizedFileName: track.normalizedName,
                extension: path.extname(track.originalPath).toLowerCase(),
                source: 'vdjfolder',
                source_file: filePath,
                metadata: track.metadata
            }));
        }

        return tracks;
    }

    /**
     * Import session olu≈ütur
     * @param {string} path - Klas√∂r yolu
     * @param {number} totalFiles - Toplam dosya sayƒ±sƒ±
     * @returns {number} Session ID
     */
    createSession(path, totalFiles) {
        try {
            // Session tracking i√ßin "import:" prefix ekle
            const sessionPath = `import:${path}`;
            
            const stmt = this.db.prepare(`
                INSERT INTO import_sessions (path, total_files, processed_files, added_files, skipped_files, error_files, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            `);
            
            const result = stmt.run(sessionPath, totalFiles, 0, 0, 0, 0, new Date().toISOString());
            return result.lastInsertRowid;
        } catch (error) {
            console.error(`‚ùå Session olu≈üturma hatasƒ±: ${error.message}`);
            throw error;
        }
    }

    /**
     * Session g√ºncelle
     * @param {number} sessionId - Session ID
     * @param {Object} updates - G√ºncelleme verileri
     */
    updateSession(sessionId, updates) {
        try {
            const fields = Object.keys(updates).map(key => `${key} = ?`).join(', ');
            const values = Object.values(updates);
            values.push(sessionId);

            const stmt = this.db.prepare(`
                UPDATE import_sessions 
                SET ${fields}
                WHERE id = ?
            `);
            
            stmt.run(...values);
        } catch (error) {
            console.error(`‚ùå Session g√ºncelleme hatasƒ±: ${error.message}`);
        }
    }

    /**
     * Dosya ekle
     * @param {Object} fileData - Dosya verisi
     * @returns {Object} Sonu√ß
     */
    addFile(fileData) {
        try {
            
            // Duplicate kontrol√º
            const existingFile = this.db.prepare(`
                SELECT id FROM music_files WHERE path = ?
            `).get(fileData.path);

            if (existingFile) {
                return { success: false, message: 'Dosya zaten mevcut' };
            }

            // fileNameOnly olu≈ütur (uzantƒ±sƒ±z dosya adƒ±)
            const fileNameOnly = path.parse(fileData.fileName).name;
            
            // Normalize edilmi≈ü dosya adƒ± olu≈ütur
            const normalizedFileName = this.normalizeFileName(fileData.fileName);

            // Dosya ekle - Database schema'ya uygun
            const stmt = this.db.prepare(`
                INSERT INTO music_files (path, fileName, fileNameOnly, normalizedFileName, extension, size, modifiedTime, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            `);

            const result = stmt.run(
                fileData.path,
                fileData.fileName,
                fileNameOnly,
                normalizedFileName,
                fileData.extension,
                fileData.size,
                fileData.modified.getTime(), // Unix timestamp
                fileData.created.toISOString() // created_at
            );

            return { success: true, message: 'Dosya eklendi' };
        } catch (error) {
            console.error(`‚ùå Dosya ekleme hatasƒ±: ${fileData.path} - ${error.message}`);
            return { success: false, message: error.message };
        }
    }

    /**
     * Track ekle
     * @param {Object} trackData - Track verisi
     * @returns {Object} Sonu√ß
     */
    addTrack(trackData) {
        try {
            // Duplicate kontrol√º
            const existingTrack = this.db.prepare(`
                SELECT id FROM tracks WHERE path = ? AND source = ?
            `).get(trackData.path, trackData.source);

            if (existingTrack) {
                return { success: false, message: 'Track zaten mevcut' };
            }

            // Track ekle
            const stmt = this.db.prepare(`
                INSERT INTO tracks (path, fileName, fileNameOnly, normalizedFileName, source, source_file)
                VALUES (?, ?, ?, ?, ?, ?)
            `);

            const result = stmt.run(
                trackData.path,
                trackData.fileName,
                trackData.fileNameOnly,
                trackData.normalizedFileName,
                trackData.source,
                trackData.source_file
            );

            return { success: true, message: 'Track eklendi' };
        } catch (error) {
            console.error(`‚ùå Track ekleme hatasƒ±: ${error.message}`);
            throw error;
        }
    }

    /**
     * Dosya adƒ±nƒ± normalize et - WordIndexService.normalize kullan
     * Bu sayede t√ºm sistem tek bir normalize fonksiyonu kullanƒ±r
     * @param {string} fileName - Dosya adƒ±
     * @returns {string} Normalize edilmi≈ü ad
     */
    normalizeFileName(fileName) {
        // WordIndexService'deki normalize fonksiyonunu kullan
        // Bu fonksiyon t√ºm d√ºnya dilleri + apostrof desteƒüi saƒülar
        return this.wordIndexService.normalize(fileName);
    }

    /**
     * Import istatistikleri
     * @returns {Object} ƒ∞statistikler
     */
    getImportStats() {
        try {
            const musicFilesCount = this.db.prepare('SELECT COUNT(*) as count FROM music_files').get().count;
            const sessionsCount = this.db.prepare('SELECT COUNT(*) as count FROM import_sessions').get().count;
            const dbSize = fs.statSync(this.dbManager.dbPath).size;

            return {
                success: true,
                data: {
                    musicFiles: musicFilesCount,
                    sessions: sessionsCount,
                    dbSize
                }
            };
        } catch (error) {
            console.error(`‚ùå ƒ∞statistik alma hatasƒ±: ${error.message}`);
            return {
                success: false,
                message: 'ƒ∞statistik alma hatasƒ±',
                error: error.message
            };
        }
    }

    /**
     * Son import oturumlarƒ±
     * @param {number} limit - Maksimum sayƒ±
     * @returns {Object} Oturum listesi
     */
    getRecentSessions(limit = 10) {
        try {
            const stmt = this.db.prepare(`
                SELECT * FROM import_sessions 
                ORDER BY created_at DESC 
                LIMIT ?
            `);
            const sessions = stmt.all(limit);

            return {
                success: true,
                data: sessions
            };
        } catch (error) {
            console.error(`‚ùå Oturum listesi alma hatasƒ±: ${error.message}`);
            return {
                success: false,
                message: 'Oturum listesi alma hatasƒ±',
                error: error.message
            };
        }
    }

    /**
     * Klas√∂r vs veritabanƒ± kontrol√º
     * @param {string} dirPath - Klas√∂r yolu
     * @returns {Object} Kar≈üƒ±la≈ütƒ±rma sonucu
     */
    checkDirectory(dirPath) {
        try {
            const files = this.scanDirectory(dirPath);
            const dbCount = this.db.prepare('SELECT COUNT(*) as count FROM music_files').get().count;

            return {
                success: true,
                data: {
                    directoryFiles: files.musicFiles.length,
                    databaseFiles: dbCount,
                    difference: files.musicFiles.length - dbCount,
                    isComplete: files.musicFiles.length === dbCount
                }
            };
        } catch (error) {
            console.error(`‚ùå Klas√∂r kontrol hatasƒ±: ${error.message}`);
            return {
                success: false,
                message: 'Klas√∂r kontrol hatasƒ±',
                error: error.message
            };
        }
    }

    /**
     * Import durumunu kontrol et
     * @param {string} dirPath - Klas√∂r yolu
     * @returns {Object} Durum bilgisi
     */
    async checkImportStatus(dirPath) {
        try {
            const sessions = this.db.prepare(`
                SELECT * FROM import_sessions 
                WHERE path = ? 
                ORDER BY created_at DESC 
                LIMIT 1
            `).get(dirPath);

            if (!sessions) {
                return {
                    success: true,
                    data: {
                        status: 'not_started',
                        message: 'Bu klas√∂r i√ßin import ba≈ülatƒ±lmamƒ±≈ü'
                    }
                };
            }

            return {
                success: true,
                data: {
                    status: sessions.processed_files === sessions.total_files ? 'completed' : 'in_progress',
                    session: sessions,
                    progress: {
                        total: sessions.total_files,
                        processed: sessions.processed_files,
                        added: sessions.added_files,
                        skipped: sessions.skipped_files,
                        errors: sessions.error_files,
                        percentage: Math.round((sessions.processed_files / sessions.total_files) * 100)
                    }
                }
            };
        } catch (error) {
            console.error(`‚ùå Import durum kontrol√º hatasƒ±: ${error.message}`);
            return {
                success: false,
                message: 'Import durum kontrol√º hatasƒ±',
                error: error.message
            };
        }
    }

    /**
     * Import doƒürulama
     * @param {string} dirPath - Klas√∂r yolu
     * @returns {Object} Doƒürulama sonucu
     */
    async verifyImport(dirPath) {
        try {
            const files = this.scanDirectory(dirPath);
            const dbCount = this.db.prepare('SELECT COUNT(*) as count FROM music_files').get().count;
            const tracksCount = this.db.prepare('SELECT COUNT(*) as count FROM tracks').get().count;

            return {
                success: true,
                data: {
                    directoryFiles: files.musicFiles.length,
                    directoryTracks: files.tracks.length,
                    databaseFiles: dbCount,
                    databaseTracks: tracksCount,
                    isComplete: files.musicFiles.length === dbCount,
                    message: files.musicFiles.length === dbCount ? 'Import tamamlanmƒ±≈ü' : 'Import eksik'
                }
            };
        } catch (error) {
            console.error(`‚ùå Import doƒürulama hatasƒ±: ${error.message}`);
            return {
                success: false,
                message: 'Import doƒürulama hatasƒ±',
                error: error.message
            };
        }
    }

    /**
     * Import session'ƒ± sil
     * @param {number} sessionId - Session ID
     * @returns {Object} Sonu√ß
     */
    deleteSession(sessionId) {
        try {
            const stmt = this.db.prepare('DELETE FROM import_sessions WHERE id = ?');
            const result = stmt.run(sessionId);

            return {
                success: true,
                data: {
                    deleted: result.changes,
                    message: result.changes > 0 ? 'Session silindi' : 'Session bulunamadƒ±'
                }
            };
        } catch (error) {
            console.error(`‚ùå Session silme hatasƒ±: ${error.message}`);
            return {
                success: false,
                message: 'Session silme hatasƒ±',
                error: error.message
            };
        }
    }

    /**
     * T√ºm import session'larƒ±nƒ± temizle
     * @returns {Object} Sonu√ß
     */
    clearAllSessions() {
        try {
            const stmt = this.db.prepare('DELETE FROM import_sessions');
            const result = stmt.run();

            return {
                success: true,
                data: {
                    deleted: result.changes,
                    message: `${result.changes} session silindi`
                }
            };
        } catch (error) {
            console.error(`‚ùå Session temizleme hatasƒ±: ${error.message}`);
            return {
                success: false,
                message: 'Session temizleme hatasƒ±',
                error: error.message
            };
        }
    }

    /**
     * M√ºzik dosyalarƒ±nƒ± asenkron olarak toplu import et (batch processing ile)
     * @param {Array} files - Dosya listesi
     * @returns {Promise<Object>} Sonu√ß
     */
    async bulkAddFilesAsync(files) {
        const startTime = Date.now();
        const timestamp = new Date().toISOString();
        let added = 0;
        let skipped = 0;
        let errors = 0;

        try {
            console.log(`[${timestamp}] [INFO] [BULK] [ASYNC] Toplu m√ºzik dosyasƒ± import ba≈ülatƒ±lƒ±yor: ${files.length} dosya`);
            
            // Ge√ßici tablo olu≈ütur
            this.db.exec(`
                CREATE TEMPORARY TABLE IF NOT EXISTS temp_music_files (
                    path TEXT PRIMARY KEY,
                    fileName TEXT NOT NULL,
                    fileNameOnly TEXT NOT NULL,
                    normalizedFileName TEXT NOT NULL,
                    extension TEXT,
                    size INTEGER,
                    modifiedTime INTEGER,
                    created_at TEXT
                )
            `);

            // K√º√ß√ºk batch size - CPU'yu serbest bƒ±rakmak i√ßin
            const batchSize = 100; // 100 dosya/batch
            const batches = [];
            
            for (let i = 0; i < files.length; i += batchSize) {
                batches.push(files.slice(i, i + batchSize));
            }

            console.log(`[${timestamp}] [DEBUG] [BULK] [ASYNC] ${batches.length} batch olu≈üturuldu (${batchSize} dosya/batch)`);

            // Ge√ßici tabloya toplu insert (UNIQUE constraint hatalarƒ±nƒ± √∂nlemek i√ßin INSERT OR REPLACE)
            const tempInsert = this.db.prepare(`
                INSERT OR REPLACE INTO temp_music_files 
                (path, fileName, fileNameOnly, normalizedFileName, extension, size, modifiedTime, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            `);

            for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                const batch = batches[batchIndex];
                const processedCount = (batchIndex + 1) * batchSize;
                const percentage = Math.min(100, Math.round((processedCount / files.length) * 100));
                
                console.log(`[${timestamp}] [DEBUG] [BULK] [BATCH] Batch ${batchIndex + 1}/${batches.length} i≈üleniyor... (${batch.length} dosya) - %${percentage}`);
                
                // Batch'i i≈üle
                for (const file of batch) {
                    try {
                        const fileNameOnly = path.basename(file.fileName, file.extension);
                        const normalizedFileName = this.normalizeFileName(file.fileName);
                        
                        tempInsert.run(
                            file.path,
                            file.fileName,
                            fileNameOnly,
                            normalizedFileName,
                            file.extension,
                            file.size,
                            file.modified.getTime(),
                            new Date().toISOString()
                        );
                        
                        // YENƒ∞: music_words kelime indexi olu≈ütur
                        this.wordIndexService.kelimeIndexiOlusturMusic(file.path, file.fileName);
                        
                        added++;
                    } catch (error) {
                        console.error(`‚ùå Dosya ekleme hatasƒ±: ${file.path} - ${error.message}`);
                        errors++;
                    }
                }
                
                // CPU'yu serbest bƒ±rak - diƒüer i≈ülemlerin √ßalƒ±≈ümasƒ±na izin ver
                if (batchIndex < batches.length - 1) {
                    await new Promise(resolve => setImmediate(resolve));
                }
            }

            // Ana tabloya toplu insert
            console.log(`[${timestamp}] [INFO] [BULK] [ASYNC] Ana tabloya aktarƒ±lƒ±yor...`);
            const result = this.db.exec(`
                INSERT OR IGNORE INTO music_files 
                (path, fileName, fileNameOnly, normalizedFileName, extension, size, modifiedTime, created_at)
                SELECT path, fileName, fileNameOnly, normalizedFileName, extension, size, modifiedTime, created_at 
                FROM temp_music_files
            `);

            // Sonu√ßlarƒ± hesapla
            const totalInTemp = this.db.prepare('SELECT COUNT(*) as count FROM temp_music_files').get().count;
            added = totalInTemp;
            skipped = files.length - totalInTemp;

            // Ge√ßici tabloyu temizle
            this.db.exec('DROP TABLE temp_music_files');

            const duration = Date.now() - startTime;
            console.log(`[${timestamp}] [INFO] [BULK] [ASYNC] ‚úÖ Toplu m√ºzik dosyasƒ± import tamamlandƒ±: ${added} eklendi, ${skipped} atlandƒ±, ${errors} hata (${duration}ms)`);

            return { added, skipped, errors, duration };

        } catch (error) {
            console.error(`[${timestamp}] [ERROR] [BULK] [ASYNC] ‚ùå Toplu m√ºzik dosyasƒ± import hatasƒ±: ${error.message}`);
            // Ge√ßici tabloyu temizle
            try {
                this.db.exec('DROP TABLE IF EXISTS temp_music_files');
            } catch (cleanupError) {
                // Ignore cleanup errors
            }
            return { added, skipped, errors: errors + 1, duration: Date.now() - startTime };
        }
    }

    /**
     * Toplu m√ºzik dosyasƒ± ekleme (SQL optimizasyonu ile)
     * @param {Array} files - M√ºzik dosyalarƒ± array'i
     * @returns {Object} Sonu√ß
     */
    async bulkAddFiles(files) {
        const startTime = Date.now();
        let added = 0;
        let skipped = 0;
        let errors = 0;

        try {
            console.log(`üöÄ Toplu m√ºzik dosyasƒ± import ba≈ülatƒ±lƒ±yor: ${files.length} dosya`);
            
            // Ge√ßici tablo olu≈ütur - transaction dƒ±≈üƒ±nda
            this.db.exec(`
                CREATE TEMPORARY TABLE IF NOT EXISTS temp_music_files (
                    path TEXT PRIMARY KEY,
                    fileName TEXT NOT NULL,
                    fileNameOnly TEXT NOT NULL,
                    normalizedFileName TEXT NOT NULL,
                    extension TEXT,
                    size INTEGER,
                    modifiedTime INTEGER,
                    created_at TEXT
                )
            `);

            // Batch size (her seferde 5000 dosya - daha b√ºy√ºk batch)
            const batchSize = 5000;
            const batches = [];
            
            for (let i = 0; i < files.length; i += batchSize) {
                batches.push(files.slice(i, i + batchSize));
            }

            console.log(`üì¶ ${batches.length} batch olu≈üturuldu (${batchSize} dosya/batch)`);

            // Ge√ßici tabloya toplu insert (UNIQUE constraint hatalarƒ±nƒ± √∂nlemek i√ßin INSERT OR REPLACE)
            const tempInsert = this.db.prepare(`
                INSERT OR REPLACE INTO temp_music_files 
                (path, fileName, fileNameOnly, normalizedFileName, extension, size, modifiedTime, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            `);

            for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                const batch = batches[batchIndex];
                    if (batchIndex % 5 === 0 || batchIndex === batches.length - 1) {
                        console.log(`‚ö° Batch ${batchIndex + 1}/${batches.length} i≈üleniyor... (${batch.length} dosya)`);
                    }
                
                // Her batch arasƒ±nda kƒ±sa bir bekleme
                if (batchIndex > 0) {
                    await new Promise(resolve => setImmediate(resolve));
                }

                // Transaction ile toplu insert
                const insertMany = this.db.transaction((files) => {
                    for (const file of files) {
                        try {
                            // fileNameOnly olu≈ütur
                            const fileNameOnly = path.parse(file.fileName).name;
                            
                            // Normalize edilmi≈ü dosya adƒ± olu≈ütur
                            const normalizedFileName = this.normalizeFileName(file.fileName);
                            
                            tempInsert.run(
                                file.path,
                                file.fileName,
                                fileNameOnly,
                                normalizedFileName,
                                file.extension,
                                file.size,
                                file.modified.getTime(),
                                file.created.toISOString()
                            );
                        } catch (error) {
                            errors++;
                            console.error(`‚ùå Temp insert hatasƒ±: ${file.path} - ${error.message}`);
                        }
                    }
                });

                insertMany(batch);
            }

                // Ge√ßici tablodan ana tabloya SQL ile duplicate kontrol√º ile insert
                console.log(`üîÑ Ge√ßici tablodan ana tabloya aktarƒ±lƒ±yor...`);
                const result = this.db.exec(`
                    INSERT OR IGNORE INTO music_files 
                    SELECT * FROM temp_music_files
                `);

            // Sonu√ßlarƒ± hesapla
            const totalInTemp = this.db.prepare('SELECT COUNT(*) as count FROM temp_music_files').get().count;
            const totalInMain = this.db.prepare('SELECT COUNT(*) as count FROM music_files').get().count;
            
            added = totalInTemp;
            skipped = files.length - totalInTemp;

            // Ge√ßici tabloyu temizle
            this.db.exec('DROP TABLE temp_music_files');

            const duration = Date.now() - startTime;
            console.log(`‚úÖ Toplu m√ºzik dosyasƒ± import tamamlandƒ±: ${added} eklendi, ${skipped} atlandƒ±, ${errors} hata (${duration}ms)`);

            return { added, skipped, errors, duration };

        } catch (error) {
            console.error(`‚ùå Toplu m√ºzik dosyasƒ± import hatasƒ±: ${error.message}`);
            // Ge√ßici tabloyu temizle
            try {
                this.db.exec('DROP TABLE IF EXISTS temp_music_files');
            } catch (cleanupError) {
                // Ignore cleanup errors
            }
            return { added, skipped, errors: errors + 1, duration: Date.now() - startTime };
        }
    }

    /**
     * Toplu track ekleme (SQL optimizasyonu ile)
     * @param {Array} tracks - Track'ler array'i
     * @returns {Object} Sonu√ß
     */
    async bulkAddTracks(tracks) {
        const startTime = Date.now();
        let added = 0;
        let skipped = 0;
        let errors = 0;

        try {
            console.log(`üöÄ Toplu track import ba≈ülatƒ±lƒ±yor: ${tracks.length} track`);
            
            // Foreign key kontrol√ºn√º ge√ßici olarak kapat
            this.db.exec('PRAGMA foreign_keys = OFF');
            
            // Ge√ßici tablo olu≈ütur - transaction dƒ±≈üƒ±nda (tracks tablosu ile aynƒ± schema)
            this.db.exec(`
                CREATE TEMPORARY TABLE IF NOT EXISTS temp_tracks (
                    path TEXT NOT NULL,
                    fileName TEXT NOT NULL,
                    fileNameOnly TEXT NOT NULL,
                    normalizedFileName TEXT NOT NULL,
                    source TEXT NOT NULL,
                    source_file TEXT,
                    created_at TEXT
                )
            `);

            // Batch size (her seferde 5000 track - daha b√ºy√ºk batch)
            const batchSize = 5000;
            const batches = [];
            
            for (let i = 0; i < tracks.length; i += batchSize) {
                batches.push(tracks.slice(i, i + batchSize));
            }

            console.log(`üì¶ ${batches.length} batch olu≈üturuldu (${batchSize} track/batch)`);

            // Ge√ßici tabloya toplu insert
            const tempInsert = this.db.prepare(`
                INSERT OR IGNORE INTO temp_tracks 
                (path, fileName, fileNameOnly, normalizedFileName, source, source_file, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            `);

            for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                const batch = batches[batchIndex];
                    if (batchIndex % 5 === 0 || batchIndex === batches.length - 1) {
                        console.log(`‚ö° Batch ${batchIndex + 1}/${batches.length} i≈üleniyor... (${batch.length} track)`);
                    }
                
                // Her batch arasƒ±nda kƒ±sa bir bekleme
                if (batchIndex > 0) {
                    await new Promise(resolve => setImmediate(resolve));
                }

                // Transaction ile toplu insert
                const insertMany = this.db.transaction((tracks) => {
                    for (const track of tracks) {
                        try {
                            tempInsert.run(
                                track.path,
                                track.fileName,
                                track.fileNameOnly,
                                track.normalizedFileName,
                                track.source,
                                track.source_file || '',
                                track.created_at || new Date().toISOString()
                            );
                        } catch (error) {
                            errors++;
                            console.error(`‚ùå Temp track insert hatasƒ±: ${track.path} - ${error.message}`);
                        }
                    }
                });

                insertMany(batch);
            }

                // Ge√ßici tablodan ana tabloya SQL ile duplicate kontrol√º ile insert
                console.log(`üîÑ Ge√ßici tablodan ana tabloya aktarƒ±lƒ±yor...`);
                const result = this.db.exec(`
                    INSERT OR IGNORE INTO tracks 
                    (path, fileName, fileNameOnly, normalizedFileName, source, source_file, created_at)
                    SELECT path, fileName, fileNameOnly, normalizedFileName, source, source_file, created_at 
                    FROM temp_tracks
                `);

            // Sonu√ßlarƒ± hesapla
            const totalInTemp = this.db.prepare('SELECT COUNT(*) as count FROM temp_tracks').get().count;
            
            added = totalInTemp;
            skipped = tracks.length - totalInTemp;

            // Ge√ßici tabloyu temizle
            this.db.exec('DROP TABLE temp_tracks');
            
            // Foreign key kontrol√ºn√º tekrar a√ß
            this.db.exec('PRAGMA foreign_keys = ON');

            const duration = Date.now() - startTime;
            console.log(`‚úÖ Toplu track import tamamlandƒ±: ${added} eklendi, ${skipped} atlandƒ±, ${errors} hata (${duration}ms)`);

            return { added, skipped, errors, duration };

        } catch (error) {
            console.error(`‚ùå Toplu track import hatasƒ±: ${error.message}`);
            // Ge√ßici tabloyu temizle
            try {
                this.db.exec('DROP TABLE IF EXISTS temp_tracks');
            } catch (cleanupError) {
                // Ignore cleanup errors
            }
            // Foreign key kontrol√ºn√º tekrar a√ß
            try {
                this.db.exec('PRAGMA foreign_keys = ON');
            } catch (fkError) {
                // Ignore FK errors
            }
            return { added, skipped, errors: errors + 1, duration: Date.now() - startTime };
        }
    }

    /**
     * Tracks'leri asenkron olarak toplu import et (batch processing ile)
     * @param {Array} tracks - Track listesi
     * @returns {Promise<Object>} Sonu√ß
     */
    async bulkAddTracksAsync(tracks) {
        const startTime = Date.now();
        const timestamp = new Date().toISOString();
        let added = 0;
        let skipped = 0;
        let errors = 0;

        try {
            console.log(`[${timestamp}] [INFO] [BULK] [ASYNC] Toplu track import ba≈ülatƒ±lƒ±yor: ${tracks.length} track`);
            
            // Foreign key kontrol√ºn√º ge√ßici olarak kapat
            this.db.exec('PRAGMA foreign_keys = OFF');
            
            // Ge√ßici tablo olu≈ütur (tracks tablosu ile aynƒ± schema - YENƒ∞ YAPI)
            this.db.exec(`
                CREATE TEMPORARY TABLE IF NOT EXISTS temp_tracks (
                    path TEXT NOT NULL,
                    fileName TEXT NOT NULL,
                    fileNameOnly TEXT NOT NULL,
                    normalizedFileName TEXT NOT NULL,
                    created_at TEXT
                )
            `);

            // K√º√ß√ºk batch size - CPU'yu serbest bƒ±rakmak i√ßin
            const batchSize = 100; // 100 track/batch
            const batches = [];
            
            for (let i = 0; i < tracks.length; i += batchSize) {
                batches.push(tracks.slice(i, i + batchSize));
            }

            console.log(`[${timestamp}] [DEBUG] [BULK] [ASYNC] ${batches.length} batch olu≈üturuldu (${batchSize} track/batch)`);

            // Ge√ßici tabloya toplu insert (id kolonu AUTO_INCREMENT olduƒüu i√ßin eklemiyor uz)
            const tempInsert = this.db.prepare(`
                INSERT INTO temp_tracks 
                (path, fileName, fileNameOnly, normalizedFileName, created_at)
                VALUES (?, ?, ?, ?, ?)
            `);

            for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                const batch = batches[batchIndex];
                const processedCount = (batchIndex + 1) * batchSize;
                const percentage = Math.min(100, Math.round((processedCount / tracks.length) * 100));
                
                console.log(`[${timestamp}] [DEBUG] [BULK] [BATCH] Batch ${batchIndex + 1}/${batches.length} i≈üleniyor... (${batch.length} track) - %${percentage}`);
                
                // Batch'i i≈üle
                for (const track of batch) {
                    try {
                        const fileNameOnly = path.basename(track.fileName, track.extension || path.extname(track.fileName));
                        const normalizedFileName = this.normalizeFileName(track.fileName);
                        
                        tempInsert.run(
                            track.path,
                            track.fileName,
                            fileNameOnly,
                            normalizedFileName,
                            new Date().toISOString()
                        );
                        
                        // YENƒ∞: track_words kelime indexi olu≈ütur
                        this.wordIndexService.kelimeIndexiOlusturTrack(
                            track.path,
                            track.fileName,
                            track.source,
                            track.playlistPath || track.source_file || ''
                        );
                        
                        added++;
                    } catch (error) {
                        console.error(`‚ùå Track ekleme hatasƒ±: ${track.path} - ${error.message}`);
                        errors++;
                    }
                }
                
                // CPU'yu serbest bƒ±rak - diƒüer i≈ülemlerin √ßalƒ±≈ümasƒ±na izin ver
                if (batchIndex < batches.length - 1) {
                    await new Promise(resolve => setImmediate(resolve));
                }
            }

            // Ana tabloya toplu insert (id kolonu hari√ß, AUTO_INCREMENT)
            console.log(`[${timestamp}] [INFO] [BULK] [ASYNC] Ana tabloya aktarƒ±lƒ±yor...`);
            const result = this.db.exec(`
                INSERT OR IGNORE INTO tracks (path, fileName, fileNameOnly, normalizedFileName, created_at)
                SELECT path, fileName, fileNameOnly, normalizedFileName, created_at FROM temp_tracks
            `);

            // Sonu√ßlarƒ± hesapla
            const totalInTemp = this.db.prepare('SELECT COUNT(*) as count FROM temp_tracks').get().count;
            added = totalInTemp;
            skipped = tracks.length - totalInTemp;

            // Ge√ßici tabloyu temizle
            this.db.exec('DROP TABLE temp_tracks');

            // Foreign key kontrol√ºn√º tekrar a√ß
            this.db.exec('PRAGMA foreign_keys = ON');

            const duration = Date.now() - startTime;
            console.log(`[${timestamp}] [INFO] [BULK] [ASYNC] ‚úÖ Toplu track import tamamlandƒ±: ${added} eklendi, ${skipped} atlandƒ±, ${errors} hata (${duration}ms)`);

            return { added, skipped, errors, duration };

        } catch (error) {
            console.error(`[${timestamp}] [ERROR] [BULK] [ASYNC] ‚ùå Toplu track import hatasƒ±: ${error.message}`);
            // Ge√ßici tabloyu temizle
            try {
                this.db.exec('DROP TABLE IF EXISTS temp_tracks');
                this.db.exec('PRAGMA foreign_keys = ON');
            } catch (fkError) {
                // Ignore FK errors
            }
            return { added, skipped, errors: errors + 1, duration: Date.now() - startTime };
        }
    }

    /**
     * Import durumunu al (t√ºm tablo sayƒ±larƒ± + progress)
     * @returns {Object} Import durumu ve database istatistikleri
     */
    async getImportStatus() {
        try {
            // Database istatistikleri
            const dbStats = this.dbManager.getCounts();
            
            // Son import session'ƒ± al
            const lastSession = this.db.prepare(`
                SELECT * FROM import_sessions 
                ORDER BY created_at DESC 
                LIMIT 1
            `).get();

            // Progress hesapla
            let progress = {
                total: 0,
                processed: 0,
                added: 0,
                skipped: 0,
                errors: 0,
                percentage: 0
            };

            if (lastSession) {
                progress = {
                    total: lastSession.total_files || 0,
                    processed: lastSession.processed_files || 0,
                    added: lastSession.added_files || 0,
                    skipped: lastSession.skipped_files || 0,
                    errors: lastSession.error_files || 0,
                    percentage: lastSession.total_files > 0 ? 
                        Math.round((lastSession.processed_files / lastSession.total_files) * 100) : 0
                };
            }

            // Status belirle
            let status = 'not_started';
            if (lastSession) {
                if (progress.percentage === 100) {
                    status = 'completed';
                } else if (progress.percentage > 0) {
                    status = 'in_progress';
                } else {
                    status = 'started';
                }
            }

            return {
                success: true,
                data: {
                    status,
                    progress,
                    database: {
                        musicFiles: dbStats.musicFiles,
                        tracks: dbStats.tracks,
                        playlists: dbStats.playlists,
                        importSessions: dbStats.import_sessions || 0,
                        dbSize: dbStats.dbSize
                    },
                    session: lastSession
                },
                message: 'Import durumu alƒ±ndƒ±'
            };

        } catch (error) {
            console.error(`‚ùå Import durum hatasƒ±: ${error.message}`);
            return {
                success: false,
                message: 'Import durum hatasƒ±',
                error: error.message
            };
        }
    }

    /**
     * Son import session'larƒ±nƒ± al
     * @param {number} limit - Maksimum session sayƒ±sƒ±
     * @returns {Object} Session listesi
     */
    getRecentSessions(limit = 10) {
        try {
            const sessions = this.db.prepare(`
                SELECT * FROM import_sessions 
                ORDER BY created_at DESC 
                LIMIT ?
            `).all(limit);

            return {
                success: true,
                data: sessions,
                message: `${sessions.length} import session bulundu`
            };

        } catch (error) {
            console.error(`‚ùå Session listesi hatasƒ±: ${error.message}`);
            return {
                success: false,
                message: 'Session listesi hatasƒ±',
                error: error.message
            };
        }
    }

    /**
     * YENƒ∞: Playlist dosyalarƒ±nƒ± toplu olarak ekle
     * @param {Array} playlistFiles - Playlist dosya bilgileri
     * @returns {Promise<Array>} Eklenen playlist'ler
     */
    async bulkAddPlaylistsAsync(playlistFiles) {
        const timestamp = new Date().toISOString();
        console.log(`[${timestamp}] [INFO] [BULK] [PLAYLIST] ${playlistFiles.length} playlist import ediliyor...`);
        
        const insertPlaylist = this.db.prepare(`
            INSERT OR REPLACE INTO playlists (path, name, type, track_count, updated_at)
            VALUES (?, ?, ?, ?, ?)
        `);
        
        const playlists = [];
        let totalTracksLinked = 0;
        
        for (const file of playlistFiles) {
            try {
                const name = path.basename(file.path, path.extname(file.path));
                const ext = path.extname(file.path).toLowerCase();
                const type = (ext === '.m3u' || ext === '.m3u8') ? 'm3u' : 'vdjfolder';
                
                const result = insertPlaylist.run(
                    file.path,
                    name,
                    type,
                    0, // track_count sonra g√ºncellenecek
                    new Date().toISOString()
                );
                
                const playlistId = result.lastInsertRowid;
                
                playlists.push({
                    id: playlistId,
                    path: file.path,
                    name,
                    type
                });
                
                // YENƒ∞: Playlist track'lerini parse et ve playlist_tracks tablosuna kaydet
                try {
                    const playlistTracks = this.parsePlaylistFile(file.path);
                    const linkedCount = this.savePlaylistTracks(playlistId, playlistTracks);
                    totalTracksLinked += linkedCount;
                } catch (trackError) {
                    console.error(`[${timestamp}] [ERROR] [PLAYLIST_TRACKS] ${file.path} track'leri kaydedilemedi: ${trackError.message}`);
                }
                
            } catch (error) {
                console.error(`‚ùå Playlist ekleme hatasƒ±: ${file.path} - ${error.message}`);
            }
        }
        
        console.log(`[${timestamp}] [INFO] [BULK] [PLAYLIST] ${playlists.length} playlist eklendi, ${totalTracksLinked} track ili≈ükilendirildi`);
        return playlists;
    }

    /**
     * Playlist ve track ili≈ükilendirmesini kaydet
     * @param {number} playlistId - Playlist ID
     * @param {Array} tracks - Track listesi (parsePlaylistFile'dan d√∂nen format)
     * @returns {number} Kaydedilen track sayƒ±sƒ±
     */
    savePlaylistTracks(playlistId, tracks) {
        const timestamp = new Date().toISOString();
        let savedCount = 0;
        let skippedCount = 0;
        
        try {
            const insertStmt = this.db.prepare(`
                INSERT OR IGNORE INTO playlist_tracks (playlist_id, track_id, track_order)
                VALUES (?, ?, ?)
            `);
            
            const findTrackStmt = this.db.prepare(`
                SELECT id FROM tracks WHERE path = ?
            `);
            
            const insertTrackStmt = this.db.prepare(`
                INSERT OR IGNORE INTO tracks (path, fileName, fileNameOnly, normalizedFileName)
                VALUES (?, ?, ?, ?)
            `);
            
            const transaction = this.db.transaction((tracks) => {
                tracks.forEach((track, index) => {
                    if (!track.path) {
                        skippedCount++;
                        return;
                    }
                    
                    // Track'i bul
                    let trackRecord = findTrackStmt.get(track.path);
                    
                    if (!trackRecord) {
                        // Track yoksa olu≈ütur
                        const result = insertTrackStmt.run(
                            track.path,
                            track.fileName || path.basename(track.path),
                            track.fileNameOnly || path.parse(track.path).name,
                            track.normalizedFileName || this.normalizeFileName(path.basename(track.path))
                        );
                        
                        // lastInsertRowid kontrol√º - eƒüer 0 ise track zaten var (INSERT OR IGNORE)
                        if (result.lastInsertRowid > 0) {
                            trackRecord = { id: result.lastInsertRowid };
                        } else {
                            // Tekrar dene
                            trackRecord = findTrackStmt.get(track.path);
                        }
                    }
                    
                    if (trackRecord) {
                        // ƒ∞li≈ükilendirmeyi kaydet (track_order 1'den ba≈ülar)
                        const result = insertStmt.run(playlistId, trackRecord.id, index + 1);
                        if (result.changes > 0) {
                            savedCount++;
                        }
                    } else {
                        skippedCount++;
                    }
                });
            });
            
            transaction(tracks);
            
            if (savedCount > 0 || skippedCount > 0) {
                console.log(`[${timestamp}] [DEBUG] [PLAYLIST_TRACKS] Playlist ${playlistId}: ${savedCount} track kaydedildi, ${skippedCount} atlandƒ±`);
            }
            
            return savedCount;
            
        } catch (error) {
            console.error(`[${timestamp}] [ERROR] [PLAYLIST_TRACKS] Playlist ${playlistId} track kaydetme hatasƒ±: ${error.message}`);
            return 0;
        }
    }
}

module.exports = ImportService;
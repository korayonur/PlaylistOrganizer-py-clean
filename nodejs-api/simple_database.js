const Database = require('better-sqlite3');
const path = require('path');
const fs = require('fs-extra');

class SimpleSQLiteDatabase {
    constructor() {
        this.dbPath = path.join(__dirname, '../musicfiles.db');
        this.db = null;
        this.initialize();
    }

    initialize() {
        try {
            // Veritabanƒ± dosyasƒ±nƒ± olu≈ütur veya a√ß
            this.db = new Database(this.dbPath);
            
            // WAL modunu etkinle≈ütir (performans i√ßin)
            this.db.pragma('journal_mode = WAL');
            this.db.pragma('synchronous = NORMAL');
            this.db.pragma('cache_size = 10000');
            this.db.pragma('temp_store = MEMORY');
            
            // Tablolarƒ± olu≈ütur
            this.createTables();
            
            console.log('‚úÖ Basit SQLite veritabanƒ± ba≈ülatƒ±ldƒ±:', this.dbPath);
        } catch (error) {
            console.error('‚ùå SQLite veritabanƒ± ba≈ülatƒ±lamadƒ±:', error);
            throw error;
        }
    }

    createTables() {
        // Sadece m√ºzik dosyalarƒ± tablosu - basit ve temiz
        this.db.exec(`
            CREATE TABLE IF NOT EXISTS music_files (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                path TEXT UNIQUE NOT NULL,
                fileName TEXT NOT NULL,
                normalizedFileName TEXT NOT NULL,
                extension TEXT,
                fileType TEXT,
                size INTEGER,
                modifiedTime TEXT,
                createdAt DATETIME DEFAULT CURRENT_TIMESTAMP,
                updatedAt DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

        // Sadece gerekli indeks - normalizedFileName i√ßin
        this.db.exec(`
            CREATE INDEX IF NOT EXISTS idx_music_files_normalized ON music_files(normalizedFileName);
        `);

        console.log('‚úÖ Basit SQLite tablolarƒ± olu≈üturuldu');
    }

    // M√ºzik dosyasƒ± ekle
    insertMusicFile(fileData) {
        const stmt = this.db.prepare(`
            INSERT OR REPLACE INTO music_files 
            (path, fileName, normalizedFileName, extension, fileType, size, modifiedTime)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `);

        const result = stmt.run(
            fileData.path,
            fileData.fileName,
            fileData.normalizedFileName,
            fileData.extension || null,
            fileData.fileType || null,
            fileData.size || null,
            fileData.modifiedTime || null,
            fileData.mimeType || null
        );

        return result.lastInsertRowid;
    }

    // Kademeli arama algoritmasƒ± - sizin √∂nerdiƒüiniz mantƒ±k
    searchProgressive(searchTerm, limit = 50) {
        const normalizedSearch = this.normalizeText(searchTerm);
        // Kelime tekrarlarƒ±nƒ± kaldƒ±r ve sƒ±rala
        const words = [...new Set(normalizedSearch.split(' ').filter(w => w.length > 0))];
        
        console.log(`üîç Kademeli Arama: "${normalizedSearch}"`);
        console.log(`üîç Kelimeler: [${words.join(', ')}]`);
        console.log(`üîç YENƒ∞ ALGORƒ∞TMA: Sondan kelime azaltma + Tek kelime atlama optimizasyonu`);
        
        // Debug log dosyasƒ±na yaz
        const fs = require('fs');
        const path = require('path');
        const logDir = path.join(__dirname, 'logs');
        const logFile = path.join(logDir, `debug_${new Date().toISOString().split('T')[0]}.log`);
        const logMessage = `[${new Date().toISOString()}] DEBUG PROGRESSIVE_SEARCH_START: "${searchTerm}" -> "${normalizedSearch}" -> [${words.join(', ')}]\n`;
        fs.appendFileSync(logFile, logMessage);
        console.log(`üîç PROGRESSIVE_SEARCH_START: "${searchTerm}" -> "${normalizedSearch}" -> [${words.join(', ')}]`);
        
        // 1. Adƒ±m: Tam e≈üle≈üme
        console.log(`üîç 1. A≈ûAMA: Tam e≈üle≈üme aranƒ±yor: "${normalizedSearch}"`);
        let results = this.searchExact(normalizedSearch, limit);
        if (results.length > 0) {
            console.log(`‚úÖ 1. A≈ûAMADA BULUNDU: Tam e≈üle≈üme: ${results.length} sonu√ß`);
            const exactMatchLog = `[${new Date().toISOString()}] DEBUG STAGE_1_EXACT_MATCH: ${results.length} results found\n`;
            fs.appendFileSync(logFile, exactMatchLog);
            
            const baseSearchInfo = {
                originalQuery: searchTerm,
                normalizedQuery: normalizedSearch,
                totalWords: words.length,
                matchedAt: 'exact',
                matchedWords: words.length,
                searchStage: 'üéØ 1. A≈ûAMA - TAM E≈ûLE≈ûME - T√ºm kelimeler bulundu',
                searchStep: 1,
                searchStepDescription: 'Tam e≈üle≈üme aramasƒ±'
            };
            
            const scoredResults = this.addScoring(results, words, words);
            const searchInfo = this.calculateSearchInfo(searchTerm, normalizedSearch, words, scoredResults, baseSearchInfo);
            
            return {
                results: scoredResults,
                searchInfo: searchInfo
            };
        }
        console.log(`‚ùå 1. A≈ûAMA: Tam e≈üle≈üme bulunamadƒ±`);
        const noExactMatchLog = `[${new Date().toISOString()}] DEBUG STAGE_1_EXACT_MATCH: 0 results found\n`;
        fs.appendFileSync(logFile, noExactMatchLog);
        
        // 2. Adƒ±m: Kelime azaltma (sondan kelime azaltma)
        for (let i = words.length - 1; i >= 1; i--) {
            // Sondan kelime azaltma (orijinal sƒ±raya g√∂re)
            const partialTerm = words.slice(0, i).join(' ');
            const stepNumber = words.length - i + 1;
            console.log(`üîç ${stepNumber}. A≈ûAMA: Kƒ±smi e≈üle≈üme aranƒ±yor: "${partialTerm}" (${i}/${words.length} kelime) - sondan azaltma`);
            results = this.searchExact(partialTerm, limit);
            if (results.length > 0) {
                console.log(`‚úÖ ${stepNumber}. A≈ûAMADA BULUNDU: Kƒ±smi e≈üle≈üme (${i} kelime): ${results.length} sonu√ß`);
                const partialMatchLog = `[${new Date().toISOString()}] DEBUG STAGE_${stepNumber}_PARTIAL_MATCH: ${results.length} results found for "${partialTerm}"\n`;
                fs.appendFileSync(logFile, partialMatchLog);
                
                // Arama terimindeki kelimeleri kullan (partialTerm - sondan azaltma)
                const searchWords = partialTerm.split(' ').filter(w => w.length > 0);
                console.log(`üîç DEBUG KISMƒ∞ E≈ûLE≈ûME: partialTerm = "${partialTerm}", searchWords = [${searchWords.join(', ')}], words = [${words.join(', ')}]`);
                const scoredResults = this.addScoring(results, searchWords, words);
                const bestMatch = scoredResults[0];
                const actualMatchedWords = bestMatch ? bestMatch.match_count : i;
                
                const baseSearchInfo = {
                    originalQuery: searchTerm,
                    normalizedQuery: normalizedSearch,
                    totalWords: words.length, // Orijinal t√ºm kelime sayƒ±sƒ±
                    matchedAt: 'partial',
                    matchedWords: actualMatchedWords,
                    searchStage: `üìâ ${stepNumber}. A≈ûAMA - KISMƒ∞ E≈ûLE≈ûME - ${actualMatchedWords}/${words.length} kelime bulundu`,
                    searchStep: stepNumber,
                    searchStepDescription: `Kƒ±smi e≈üle≈üme aramasƒ± (${actualMatchedWords} kelime)`,
                    searchedTerm: partialTerm
                };
                
                // calculateSearchInfo'da orijinal t√ºm kelimeleri kullan
                const searchInfo = this.calculateSearchInfo(searchTerm, normalizedSearch, words, scoredResults, baseSearchInfo, searchWords);
                
                console.log(`üîç DEBUG KISMƒ∞ E≈ûLE≈ûME RETURN: scoredResults[0].similarity_score = ${scoredResults[0] ? scoredResults[0].similarity_score : 'null'}`);
                return {
                    results: scoredResults,
                    searchInfo: searchInfo
                };
            }
            console.log(`‚ùå ${stepNumber}. A≈ûAMA: Kƒ±smi e≈üle≈üme bulunamadƒ±: "${partialTerm}"`);
        }
        
        // 3. Adƒ±m: Tek kelime arama (uzunluk sƒ±rasƒ±na g√∂re)
        // Optimizasyon: Tek kelimeye d√º≈üt√ºƒü√ºnde arama yapƒ±lmaz, direkt uzunluk sƒ±rasƒ±na ge√ßer
        const singleWordStepStart = words.length + 1;
        console.log(`üîç ${singleWordStepStart}. A≈ûAMA: Tek kelimeye d√º≈üt√º, arama yapƒ±lmaz - direkt uzunluk sƒ±rasƒ±na ge√ßiliyor`);
        const singleWordSkipLog = `[${new Date().toISOString()}] DEBUG STAGE_${singleWordStepStart}_SINGLE_WORD_SKIP: Skipped single word search, proceeding to length-based sorting\n`;
        fs.appendFileSync(logFile, singleWordSkipLog);
        
        // Kelimeleri uzunluklarƒ±na g√∂re sƒ±rala (uzun olanlar daha spesifik)
        const sortedWords = [...words].sort((a, b) => b.length - a.length);
        
        for (let i = 0; i < sortedWords.length; i++) {
            const word = sortedWords[i];
            const originalIndex = words.indexOf(word);
            const stepNumber = singleWordStepStart + i;
            console.log(`üîç ${stepNumber}. A≈ûAMA: Tek kelime aranƒ±yor: "${word}" (uzunluk: ${word.length}, ${originalIndex + 1}/${words.length}. kelime)`);
            results = this.searchExact(word, limit);
            if (results.length > 0) {
                console.log(`‚úÖ ${stepNumber}. A≈ûAMADA BULUNDU: Tek kelime e≈üle≈üme: ${results.length} sonu√ß`);
                const singleWordLog = `[${new Date().toISOString()}] DEBUG STAGE_${stepNumber}_SINGLE_WORD: ${results.length} results found for "${word}"\n`;
                fs.appendFileSync(logFile, singleWordLog);
                
                const baseSearchInfo = {
                    originalQuery: searchTerm,
                    normalizedQuery: normalizedSearch,
                    totalWords: words.length,
                    matchedAt: 'single',
                    matchedWords: 1,
                    matchedWordIndex: originalIndex + 1,
                    matchedWord: word,
                    searchStage: `üîç ${stepNumber}. A≈ûAMA - TEK KELƒ∞ME E≈ûLE≈ûME - ${originalIndex + 1}/${words.length}. kelime: "${word}"`,
                    searchStep: stepNumber,
                    searchStepDescription: `Tek kelime aramasƒ± (${originalIndex + 1}/${words.length}. kelime)`,
                    searchedTerm: word
                };
                
                // calculateSearchInfo i√ßinde addScoring yapƒ±ldƒ±, o sonucu kullan
                const scoredResults = this.addScoring(results, [word], words);
                const searchInfo = this.calculateSearchInfo(searchTerm, normalizedSearch, words, scoredResults, baseSearchInfo, [word]);
                
                // Debug log dosyasƒ±na yaz
                const logMessage = `[${new Date().toISOString()}] DEBUG PROGRESSIVE_SEARCH_RETURN: results_count=${scoredResults.length}, first_result_similarity=${scoredResults[0] ? scoredResults[0].similarity_score : 'null'}\n`;
                fs.appendFileSync(logFile, logMessage);
                
                return {
                    results: scoredResults,
                    searchInfo: searchInfo
                };
            }
            console.log(`‚ùå ${stepNumber}. A≈ûAMA: Tek kelime e≈üle≈üme bulunamadƒ±: "${word}"`);
        }
        
        console.log(`‚ùå Hi√ßbir e≈üle≈üme bulunamadƒ±`);
        
        const baseSearchInfo = {
            originalQuery: searchTerm,
            normalizedQuery: normalizedSearch,
            totalWords: words.length,
            matchedAt: 'none',
            matchedWords: 0,
            searchStage: '‚ùå Hƒ∞√áBƒ∞R E≈ûLE≈ûME BULUNAMADI',
            searchStep: 0,
            searchStepDescription: 'T√ºm a≈üamalar denendi, sonu√ß bulunamadƒ±'
        };
        
        const searchInfo = this.calculateSearchInfo(searchTerm, normalizedSearch, words, [], baseSearchInfo);
        
        return {
            results: [],
            searchInfo: searchInfo
        };
    }

    // Basit LIKE sorgusu - √ßok hƒ±zlƒ±
    searchExact(term, limit) {
        const stmt = this.db.prepare(`
            SELECT * FROM music_files 
            WHERE normalizedFileName LIKE ?
            ORDER BY 
                CASE 
                    WHEN normalizedFileName LIKE ? THEN 1
                    WHEN normalizedFileName LIKE ? THEN 2
                    ELSE 3
                END,
                LENGTH(normalizedFileName) ASC
            LIMIT ?
        `);
        
        const pattern = `%${term}%`;
        const exactMatch = `%${term}%`;
        const startsWith = `${term}%`;
        
        return stmt.all(pattern, exactMatch, startsWith, limit);
    }

    // Puanlama ekle - adil sistem
    addScoring(results, searchWords, originalWords = null) {
        console.log(`üîç DEBUG addScoring: searchWords = [${searchWords.join(', ')}] (${searchWords.length} kelime), originalWords = [${(originalWords || []).join(', ')}]`);
        
        // Debug log dosyasƒ±na yaz
        const fs = require('fs');
        const path = require('path');
        const logDir = path.join(__dirname, 'logs');
        const logFile = path.join(logDir, `debug_${new Date().toISOString().split('T')[0]}.log`);
        const logMessage = `[${new Date().toISOString()}] DEBUG ADD_SCORING_START: searchWords=[${searchWords.join(', ')}], results_count=${results.length}, originalWords=[${(originalWords || []).join(', ')}]\n`;
        fs.appendFileSync(logFile, logMessage);
        
        return results.map(result => {
            const fileWords = result.normalizedFileName.split(' ').filter(w => w.length > 0);
            // Orijinal kelimeler varsa onlarƒ± kullan, yoksa searchWords kullan
            const allOriginalWords = originalWords || searchWords;
            const searchWordCount = allOriginalWords.length;
            const fileWordCount = fileWords.length;
            
            // E≈üle≈üen kelime sayƒ±sƒ±nƒ± hesapla - ORƒ∞Jƒ∞NAL T√úM KELƒ∞MELERE G√ñRE
            let matchCount = 0;
            const matchedWords = [];
            allOriginalWords.forEach(originalWord => {
                if (fileWords.some(fileWord => fileWord === originalWord)) {
                    matchCount++;
                    matchedWords.push(originalWord);
                }
            });
            
            // Debug log dosyasƒ±na yaz
            const matchDetailLog = `[${new Date().toISOString()}] DEBUG MATCH_DETAIL: ${result.fileName} -> fileWords=[${fileWords.join(', ')}], allOriginalWords=[${allOriginalWords.join(', ')}], matchedWords=[${matchedWords.join(', ')}], matchCount=${matchCount}\n`;
            fs.appendFileSync(logFile, matchDetailLog);
            
            // Puanlama: e≈üle≈üen kelime sayƒ±sƒ± / orijinal arama kelime sayƒ±sƒ± (0-1 arasƒ±)
            const similarity = searchWordCount > 0 ? matchCount / searchWordCount : 0;
            
            console.log(`üîç DEBUG ${result.fileName}: ${matchCount}/${searchWordCount} = ${similarity}`);
            
            const scoredResult = {
                ...result,
                similarity_score: similarity,
                match_count: matchCount,
                total_words: fileWordCount,
                matched_words: matchedWords
            };
            
            console.log(`üîç DEBUG FINAL: ${result.fileName} -> similarity_score: ${scoredResult.similarity_score}, match_count: ${scoredResult.match_count}, total_words: ${scoredResult.total_words}, keys: ${Object.keys(scoredResult).join(', ')}`);
            
            // Debug log dosyasƒ±na yaz
            const logMessage = `[${new Date().toISOString()}] DEBUG ADD_SCORING_RESULT: ${result.fileName} -> similarity_score: ${scoredResult.similarity_score}, match_count: ${scoredResult.match_count}, total_words: ${scoredResult.total_words}\n`;
            fs.appendFileSync(logFile, logMessage);
            
            return scoredResult;
        }).sort((a, b) => b.similarity_score - a.similarity_score);
    }

    /**
     * SearchInfo hesaplama fonksiyonu - t√ºm arama t√ºrleri i√ßin ortak
     * @param {string} searchTerm - Orijinal arama terimi
     * @param {string} normalizedSearch - Normalize edilmi≈ü arama terimi
     * @param {Array} words - Arama terimindeki kelimeler (kƒ±smi veya tam)
     * @param {Array} results - SQL sonu√ßlarƒ±
     * @param {Object} baseSearchInfo - Temel searchInfo objesi
     * @returns {Object} - Tamamlanmƒ±≈ü searchInfo objesi
     */
    calculateSearchInfo(searchTerm, normalizedSearch, words, results, baseSearchInfo, searchWords = null) {
        // searchWords parametresi varsa onu kullan, yoksa words kullan
        const scoringWords = searchWords || words;
        console.log(`üîç DEBUG calculateSearchInfo: searchWords = [${(searchWords || []).join(', ')}], words = [${words.join(', ')}], scoringWords = [${scoringWords.join(', ')}]`);
        
        // En iyi e≈üle≈üme bilgilerini hesapla - ORƒ∞Jƒ∞NAL T√úM KELƒ∞MELERE G√ñRE
        let bestMatchWords = 0;
        let bestMatchSimilarity = 0;
        if (results.length > 0) {
            const bestMatch = results[0];
            const fileWords = bestMatch.normalizedFileName.split(' ').filter(w => w.length > 0);
            // Orijinal t√ºm kelimeleri kullan (normalizedSearch'ten)
            const originalWords = normalizedSearch.split(' ').filter(w => w.length > 0);
            originalWords.forEach(originalWord => {
                if (fileWords.some(fileWord => fileWord === originalWord)) {
                    bestMatchWords++;
                }
            });
            bestMatchSimilarity = originalWords.length > 0 ? bestMatchWords / originalWords.length : 0;
        }
        
        return {
            ...baseSearchInfo,
            bestMatchWords: bestMatchWords,
            bestMatchTotalWords: normalizedSearch.split(' ').filter(w => w.length > 0).length,
            bestMatchSimilarity: bestMatchSimilarity
        };
    }

    // T√ºm dosyalarƒ± getir
    getAllFiles() {
        const stmt = this.db.prepare('SELECT * FROM music_files ORDER BY normalizedFileName');
        return stmt.all();
    }

    // Dosya sayƒ±sƒ±
    getFileCount() {
        const stmt = this.db.prepare('SELECT COUNT(*) as count FROM music_files');
        return stmt.get().count;
    }

    // Veritabanƒ± istatistikleri
    getStats() {
        const fileCount = this.getFileCount();
        const dbSize = fs.statSync(this.dbPath).size;

        return {
            fileCount,
            dbSize,
            dbPath: this.dbPath
        };
    }

    // Veritabanƒ±nƒ± temizle
    clear() {
        this.db.exec('DELETE FROM music_files');
        console.log('‚úÖ Veritabanƒ± temizlendi');
    }

    // Veritabanƒ±nƒ± temizle
    clearDatabase() {
        try {
            this.db.exec('DELETE FROM music_files');
            console.log('üóëÔ∏è SQLite veritabanƒ± temizlendi');
        } catch (error) {
            console.error('‚ùå Veritabanƒ± temizleme hatasƒ±:', error);
            throw error;
        }
    }

    // Dosya ekle
    addFile(fileData) {
        try {
            const stmt = this.db.prepare(`
                INSERT OR REPLACE INTO music_files 
                (path, fileName, normalizedFileName, extension, fileType, size, modifiedTime)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            `);
            
            const result = stmt.run(
                fileData.path,
                fileData.fileName,
                fileData.normalizedFileName,
                fileData.extension || null,
                fileData.fileType || null,
                fileData.size || null,
                fileData.modifiedTime || null,
            );
            
            return result;
        } catch (error) {
            console.error('‚ùå Dosya ekleme hatasƒ±:', error);
            throw error;
        }
    }

    // Veritabanƒ±nƒ± kapat
    close() {
        if (this.db) {
            this.db.close();
            this.db = null;
        }
    }

    // T√ºrk√ße karakter normalizasyonu
    normalizeText(text) {
        const charMap = {
            "ƒü": "g", "ƒû": "G", "ƒ±": "i", "I": "I", "ƒ∞": "I", 
            "≈ü": "s", "≈û": "S", "√ß": "c", "√á": "C", 
            "√º": "u", "√ú": "U", "√∂": "o", "√ñ": "O",
            "√†": "a", "√°": "a", "√¢": "a", "√£": "a", "√§": "a", "√•": "a", "√¶": "ae",
            "√®": "e", "√©": "e", "√™": "e", "√´": "e", "√¨": "i", "√≠": "i", "√Æ": "i", "√Ø": "i",
            "√≤": "o", "√≥": "o", "√¥": "o", "√µ": "o", "√∏": "o", "√π": "u", "√∫": "u", "√ª": "u",
            "√Ω": "y", "√æ": "th", "√ø": "y", "√ü": "ss", "√∞": "d", "√±": "n"
        };

        let normalized = text;
        normalized = normalized.normalize("NFKC");
        normalized = normalized.split('').map(c => charMap[c] || c).join('');
        normalized = normalized.toLowerCase();
        normalized = normalized.replace(/[^a-z0-9\s]/g, ' ');
        normalized = normalized.replace(/\s+/g, ' ').trim();
        
        return normalized;
    }
}

module.exports = SimpleSQLiteDatabase;

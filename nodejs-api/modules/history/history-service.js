'use strict';

const fs = require('fs');
const path = require('path');
const { getLogger } = require('../../shared/logger');
const { getDatabase } = require('../../shared/database');
const { WordSimilaritySearch } = require('../../shared/utils');

/**
 * History Service - Basitle≈ütirilmi≈ü
 */
class HistoryService {
    constructor() {
        this.dbManager = getDatabase();
        this.db = this.dbManager.db;
        this.logger = getLogger().module('HistoryService');
    }


    /**
     * Tam yol e≈üle≈ümesi yap
     * @returns {number} E≈üle≈ütirilen track sayƒ±sƒ±
     */
    performExactPathMatch() {
        const updateStmt = this.db.prepare(`
            UPDATE tracks 
            SET is_matched = 1, 
                matched_music_file_id = (
                    SELECT mf.id 
                    FROM music_files mf 
                    WHERE mf.path = tracks.path
                ),
                updated_at = CURRENT_TIMESTAMP
            WHERE tracks.path IN (
                SELECT mf.path 
                FROM music_files mf 
                WHERE mf.path = tracks.path
            ) AND tracks.is_matched = 0
        `);

        const result = updateStmt.run();
        return result.changes;
    }

    /**
     * Filename-only e≈üle≈ümesi yap
     * @returns {number} E≈üle≈ütirilen track sayƒ±sƒ±
     */
    performFilenameMatch() {
        const updateStmt = this.db.prepare(`
            UPDATE tracks 
            SET is_matched = 1, 
                matched_music_file_id = (
                    SELECT mf.id 
                    FROM music_files mf 
                    WHERE mf.fileNameOnly = tracks.fileNameOnly
                    LIMIT 1
                ),
                updated_at = CURRENT_TIMESTAMP
            WHERE tracks.is_matched = 0 
            AND tracks.fileNameOnly IN (
                SELECT mf.fileNameOnly 
                FROM music_files mf 
                WHERE mf.fileNameOnly = tracks.fileNameOnly
            )
        `);

        const result = updateStmt.run();
        return result.changes;
    }

    /**
     * Benzerlik e≈üle≈ümesi yap (Levenshtein distance)
     * @param {number} threshold - Minimum benzerlik oranƒ± (0.0-1.0)
     * @param {number} limit - Maksimum i≈ülenecek track sayƒ±sƒ±
     * @returns {number} E≈üle≈ütirilen track sayƒ±sƒ±
     */
    performSimilarityMatch(threshold = 0.4, limit = 1000) {
        try {
            this.logger.info(`Benzerlik e≈üle≈ümesi ba≈ülatƒ±lƒ±yor (threshold: ${threshold}, limit: ${limit})`);
            
            // E≈üle≈ümemi≈ü track'leri al
            const unmatchedTracks = this.db.prepare(`
                SELECT id, path, fileName, fileNameOnly, normalizedFileName
                FROM tracks 
                WHERE is_matched = 0 
                LIMIT ?
            `).all(limit);

            this.logger.info(`${unmatchedTracks.length} e≈üle≈ümemi≈ü track bulundu`);

            let matchedCount = 0;
            const { normalizeFileName } = require('../../shared/utils');

            for (const track of unmatchedTracks) {
                try {
                    // Bu track i√ßin en benzer music_file'ƒ± bul
                    const bestMatch = this.findBestSimilarityMatch(track, threshold);
                    
                    if (bestMatch) {
                        // E≈üle≈ümeyi kaydet
                        const updateStmt = this.db.prepare(`
                            UPDATE tracks 
                            SET is_matched = 1, 
                                matched_music_file_id = ?,
                                updated_at = CURRENT_TIMESTAMP
                            WHERE id = ?
                        `);
                        
                        updateStmt.run(bestMatch.id, track.id);
                        matchedCount++;
                        
                        this.logger.debug(`‚úÖ E≈üle≈üti: ${track.fileName} ‚Üí ${bestMatch.fileName} (skor: ${bestMatch.similarity.toFixed(3)})`);
                    }
                } catch (error) {
                    this.logger.error(`Track e≈üle≈üme hatasƒ± (${track.fileName}):`, error);
                }
            }

            this.logger.info(`‚úÖ ${matchedCount} track benzerlik e≈üle≈ümesi ile e≈üle≈ütirildi`);
            return matchedCount;

        } catch (error) {
            this.logger.error('Benzerlik e≈üle≈ümesi hatasƒ±:', error);
            return 0;
        }
    }

    /**
     * Kelime √ßƒ±kartmalƒ± benzerlik e≈üle≈ütirmesi yap
     * @param {number} threshold - Minimum benzerlik oranƒ± (0.0-1.0)
     * @param {number} limit - Maksimum i≈ülenecek track sayƒ±sƒ±
     * @returns {number} E≈üle≈ütirilen track sayƒ±sƒ±
     */
    performWordSimilarityMatch(threshold = 0.6, limit = 1000) {
        try {
            this.logger.info(`Kelime √ßƒ±kartmalƒ± benzerlik e≈üle≈ütirmesi ba≈ülatƒ±lƒ±yor (threshold: ${threshold}, limit: ${limit})`);

            // E≈üle≈ümemi≈ü track'leri al (anlamlƒ± track'leri bul)
            const unmatchedTracks = this.db.prepare(`
                SELECT * FROM tracks 
                WHERE is_matched = 0 
                AND normalizedFileName LIKE '% %'
                AND LENGTH(normalizedFileName) > 15
                ORDER BY id 
                LIMIT ?
            `).all(limit);

            const fs = require('fs');
            fs.appendFileSync('/tmp/debug.log', `üîç ${unmatchedTracks.length} e≈üle≈ümemi≈ü track bulundu\n`);
            console.log(`üîç ${unmatchedTracks.length} e≈üle≈ümemi≈ü track bulundu`);
            this.logger.info(`${unmatchedTracks.length} e≈üle≈ümemi≈ü track bulundu`);

            let matchedCount = 0;

            for (let i = 0; i < Math.min(unmatchedTracks.length, 5); i++) {
                const track = unmatchedTracks[i];
                fs.appendFileSync('/tmp/debug.log', `üîÑ ƒ∞≈üleniyor ${i+1}/${Math.min(unmatchedTracks.length, 5)}: ${track.normalizedFileName}\n`);
                console.log(`üîÑ ƒ∞≈üleniyor ${i+1}/${Math.min(unmatchedTracks.length, 5)}: ${track.normalizedFileName}`);
                this.logger.info(`ƒ∞≈üleniyor ${i+1}/${Math.min(unmatchedTracks.length, 5)}: ${track.normalizedFileName}`);
                // Kademeli arama yap
                const searchResult = this.searchStepByStep(track.normalizedFileName);
                
                if (searchResult && searchResult.results.length > 0) {
                    fs.appendFileSync('/tmp/debug.log', `üîç En iyi e≈üle≈üme aranƒ±yor: ${searchResult.results.length} aday\n`);
                    
                    // En iyi e≈üle≈ümeyi bul
                    const bestMatch = this.findBestMatch(track.normalizedFileName, searchResult.results);
                    
                    fs.appendFileSync('/tmp/debug.log', `üìä En iyi e≈üle≈üme: ${bestMatch ? `skor=${bestMatch.score.toFixed(3)}, threshold=${threshold}` : 'bulunamadƒ±'}\n`);
                    
                    if (bestMatch && bestMatch.score >= threshold) {
                        // E≈üle≈ümeyi kaydet
                        const updateStmt = this.db.prepare(`
                            UPDATE tracks
                            SET is_matched = 1,
                                matched_music_file_id = ?,
                                updated_at = CURRENT_TIMESTAMP
                            WHERE id = ?
                        `);

                        updateStmt.run(bestMatch.match.id, track.id);
                        matchedCount++;

                        fs.appendFileSync('/tmp/debug.log', `‚úÖ E≈üle≈üme kaydedildi: ${track.normalizedFileName} ‚Üí ${bestMatch.match.normalizedFileName} (skor: ${bestMatch.score.toFixed(3)})\n`);
                        this.logger.debug(`‚úÖ Kelime e≈üle≈üti: ${track.normalizedFileName} ‚Üí ${bestMatch.match.normalizedFileName} (skor: ${bestMatch.score.toFixed(3)})`);
                    } else {
                        fs.appendFileSync('/tmp/debug.log', `‚ùå E≈üle≈üme yetersiz: ${bestMatch ? bestMatch.score.toFixed(3) : 'bulunamadƒ±'} < ${threshold}\n`);
                    }
                }
            }

            this.logger.info(`‚úÖ ${matchedCount} track kelime √ßƒ±kartmalƒ± e≈üle≈ümesi ile e≈üle≈ütirildi`);
            return matchedCount;

        } catch (error) {
            this.logger.error('Kelime √ßƒ±kartmalƒ± e≈üle≈ümesi hatasƒ±:', error);
            return 0;
        }
    }

    /**
     * Rakam filtreleme - ba≈ütaki rakamlarƒ± kaldƒ±r
     * @param {string} text - Filtrelenecek metin
     * @returns {string} Filtrelenmi≈ü metin
     */
    filterNumbers(text) {
        return text.replace(/^\d+\s*/, '').trim();
    }

    /**
     * Kelime kombinasyonlarƒ± olu≈üturma (en uzundan ba≈üla)
     * @param {string[]} words - Kelime dizisi
     * @returns {string[]} Kombinasyon dizisi
     */
    generateWordCombinations(words) {
        const combinations = [];
        for (let i = words.length; i >= 1; i--) {
            for (let j = 0; j <= words.length - i; j++) {
                combinations.push(words.slice(j, j + i).join(' '));
            }
        }
        return combinations;
    }

    /**
     * Kademeli arama - en uzun kelime kombinasyonundan ba≈üla
     * @param {string} trackName - Aranacak track adƒ±
     * @returns {Object|null} Arama sonucu
     */
    searchStepByStep(trackName) {
        try {
            const filteredName = this.filterNumbers(trackName);
            const words = filteredName.split(' ').filter(w => w.length > 0);
            const combinations = this.generateWordCombinations(words);

            fs.appendFileSync('/tmp/debug.log', `üîç Kademeli arama: "${trackName}" ‚Üí "${filteredName}" (${words.length} kelime)\n`);
            fs.appendFileSync('/tmp/debug.log', `üìù Kombinasyonlar: ${combinations.slice(0, 3).join(', ')}...\n`);
            console.log(`üîç Kademeli arama: "${trackName}" ‚Üí "${filteredName}" (${words.length} kelime)`);
            console.log(`üìù Kombinasyonlar: ${combinations.slice(0, 3).join(', ')}...`);
            this.logger.info(`Kademeli arama: "${trackName}" ‚Üí "${filteredName}" (${words.length} kelime)`);
            this.logger.info(`Kombinasyonlar: ${combinations.slice(0, 3).join(', ')}...`);

            for (const combination of combinations) {
                const results = this.db.prepare(`
                    SELECT * FROM music_files 
                    WHERE normalizedFileName LIKE ?
                `).all(`%${combination}%`);

                if (results.length > 0) {
                    fs.appendFileSync('/tmp/debug.log', `‚úÖ Bulundu: "${combination}" ‚Üí ${results.length} sonu√ß\n`);
                    console.log(`‚úÖ Bulundu: "${combination}" ‚Üí ${results.length} sonu√ß`);
                    this.logger.info(`‚úÖ Bulundu: "${combination}" ‚Üí ${results.length} sonu√ß`);
                    return { combination, results };
                }
            }

            fs.appendFileSync('/tmp/debug.log', `‚ùå Bulunamadƒ±: "${trackName}"\n`);
            console.log(`‚ùå Bulunamadƒ±: "${trackName}"`);
            this.logger.info(`‚ùå Bulunamadƒ±: "${trackName}"`);
            return null;

        } catch (error) {
            this.logger.error('Kademeli arama hatasƒ±:', error);
            return null;
        }
    }

    /**
     * En iyi e≈üle≈ümeyi bulma
     * @param {string} originalName - Orijinal track adƒ±
     * @param {Array} candidates - Aday m√ºzik dosyalarƒ±
     * @returns {Object|null} En iyi e≈üle≈üme
     */
    findBestMatch(originalName, candidates) {
        let bestMatch = null;
        let bestScore = 0;

        for (const candidate of candidates) {
            const score = this.calculateWordSimilarity(originalName, candidate.normalizedFileName);
            if (score > bestScore) {
                bestScore = score;
                bestMatch = candidate;
            }
        }

        return bestMatch ? { match: bestMatch, score: bestScore } : null;
    }

    /**
     * Detaylƒ± kelime √ßƒ±kartmalƒ± benzerlik hesaplama
     * @param {string} trackName - Track adƒ±
     * @param {string} musicName - M√ºzik dosyasƒ± adƒ±
     * @returns {number} Benzerlik oranƒ± (0.0-1.0)
     */
    calculateWordSimilarity(trackName, musicName) {
        const trackWords = trackName.split(' ').filter(w => w.length > 0);
        const musicWords = musicName.split(' ').filter(w => w.length > 0);

        let matchedWords = 0;
        const usedMusicWords = new Set();

        for (const trackWord of trackWords) {
            let bestMatch = null;
            let bestScore = 0;

            for (let i = 0; i < musicWords.length; i++) {
                if (usedMusicWords.has(i)) continue;

                const musicWord = musicWords[i];
                const similarity = this.calculateSimilarity(trackWord, musicWord);

                if (similarity > 0.7 && similarity > bestScore) {
                    bestMatch = i;
                    bestScore = similarity;
                }
            }

            if (bestMatch !== null) {
                matchedWords++;
                usedMusicWords.add(bestMatch);
            }
        }

        return matchedWords / trackWords.length;
    }

    /**
     * Track i√ßin en iyi benzerlik e≈üle≈ümesini bul
     * @param {Object} track - Track objesi
     * @param {number} threshold - Minimum benzerlik oranƒ±
     * @returns {Object|null} En iyi e≈üle≈üme veya null
     */
    findBestSimilarityMatch(track, threshold) {
        try {
            // T√ºm music_files'larƒ± al
            const musicFiles = this.db.prepare(`
                SELECT id, path, fileName, fileNameOnly, normalizedFileName
                FROM music_files
            `).all();

            let bestMatch = null;
            let bestScore = 0;

            const { normalizeFileName } = require('../../shared/utils');

            for (const musicFile of musicFiles) {
                // Benzerlik skorunu hesapla
                const similarity = this.calculateSimilarity(
                    track.normalizedFileName, 
                    musicFile.normalizedFileName
                );

                if (similarity >= threshold && similarity > bestScore) {
                    bestMatch = {
                        id: musicFile.id,
                        path: musicFile.path,
                        fileName: musicFile.fileName,
                        similarity: similarity
                    };
                    bestScore = similarity;
                }
            }

            return bestMatch;

        } catch (error) {
            this.logger.error('Benzerlik hesaplama hatasƒ±:', error);
            return null;
        }
    }

    /**
     * ƒ∞ki string arasƒ±ndaki benzerliƒüi hesapla (Levenshtein distance)
     * @param {string} str1 - ƒ∞lk string
     * @param {string} str2 - ƒ∞kinci string
     * @returns {number} Benzerlik oranƒ± (0.0-1.0)
     */
    calculateSimilarity(str1, str2) {
        if (!str1 || !str2) return 0;
        
        const distance = this.levenshteinDistance(str1.toLowerCase(), str2.toLowerCase());
        const maxLength = Math.max(str1.length, str2.length);
        
        return maxLength === 0 ? 1 : 1 - (distance / maxLength);
    }

    /**
     * Levenshtein distance hesapla
     * @param {string} str1 - ƒ∞lk string
     * @param {string} str2 - ƒ∞kinci string
     * @returns {number} Distance deƒüeri
     */
    levenshteinDistance(str1, str2) {
        const matrix = [];
        
        for (let i = 0; i <= str2.length; i++) {
            matrix[i] = [i];
        }
        
        for (let j = 0; j <= str1.length; j++) {
            matrix[0][j] = j;
        }
        
        for (let i = 1; i <= str2.length; i++) {
            for (let j = 1; j <= str1.length; j++) {
                if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j - 1] + 1,  // substitution
                        matrix[i][j - 1] + 1,      // insertion
                        matrix[i - 1][j] + 1       // deletion
                    );
                }
            }
        }
        
        return matrix[str2.length][str1.length];
    }

    /**
     * E≈üle≈ütirme istatistiklerini al
     * @returns {Object} ƒ∞statistikler
     */
    getMatchStats() {
        const totalTracks = this.db.prepare('SELECT COUNT(*) as count FROM tracks').get().count;
        const matchedTracks = this.db.prepare('SELECT COUNT(*) as count FROM tracks WHERE is_matched = 1').get().count;
        const unmatchedTracks = this.db.prepare('SELECT COUNT(*) as count FROM tracks WHERE is_matched = 0').get().count;
        const totalMusicFiles = this.db.prepare('SELECT COUNT(*) as count FROM music_files').get().count;

        return {
            totalTracks,
            matchedTracks,
            unmatchedTracks,
            totalMusicFiles,
            matchRate: totalTracks > 0 ? ((matchedTracks / totalTracks) * 100).toFixed(2) : 0
        };
    }

    /**
     * History dosyalarƒ±nƒ± tara ve import et
     * @param {string} historyRoot - History klas√∂r yolu
     * @returns {Promise<Object>} Import sonucu
     */
    async scanAndImport(historyRoot) {
        try {
            this.logger.info(`History tarama ba≈ülatƒ±lƒ±yor: ${historyRoot}`);

            // 1. History dosyalarƒ±nƒ± bul
            const historyFiles = this.scanHistoryFiles(historyRoot);
            this.logger.info(`${historyFiles.length} history dosyasƒ± bulundu`);

            let totalTracks = 0;
            let processedFiles = 0;

            // 2. Her dosyayƒ± i≈üle
            for (const historyFile of historyFiles) {
                try {
                    // Duplicate kontrol√º
                    const isAlreadyProcessed = this.isFileProcessed(historyFile.filePath);
                    if (isAlreadyProcessed) {
                        this.logger.info(`‚è≠Ô∏è Skipping already processed file: ${historyFile.fileName}`);
                        processedFiles++;
                        continue;
                    }

                    this.logger.info(`üîç Processing history file: ${historyFile.filePath}`);
                    const tracks = this.extractTracksFromFile(historyFile.filePath);
                    this.logger.info(`üìä Extracted ${tracks ? tracks.length : 0} tracks from ${historyFile.fileName}`);
                    
                    if (tracks && tracks.length > 0) {
                        this.insertTracks(tracks, historyFile.filePath);
                        totalTracks += tracks.length;
                        this.logger.info(`‚úÖ Inserted ${tracks.length} tracks into database`);
                    }
                    processedFiles++;
                } catch (error) {
                    this.logger.error(`History dosyasƒ± i≈üleme hatasƒ±: ${historyFile.filePath}`, { error: error.message });
                }
            }

            return {
                success: true,
                data: {
                processedFiles,
                totalTracks,
                    historyFiles: historyFiles.length
                },
                message: 'History import ba≈üarƒ±yla tamamlandƒ±'
            };

        } catch (error) {
            this.logger.error(`History scan hatasƒ±: ${error.message}`, { error: error.message });
            return {
                success: false,
                message: 'History scan hatasƒ±',
                error: error.message
            };
        }
    }

    /**
     * History dosyalarƒ±nƒ± tara
     * @param {string} historyRoot - History klas√∂r yolu
     * @returns {Array} History dosya listesi
     */
    scanHistoryFiles(historyRoot) {
        const historyFiles = [];
        
        try {
            this.logger.info(`History klas√∂r√º taranƒ±yor: ${historyRoot}`);
            const items = fs.readdirSync(historyRoot);
            this.logger.info(`${items.length} dosya/klas√∂r bulundu`);
            
            for (const item of items) {
                const itemPath = path.join(historyRoot, item);
                const stats = fs.statSync(itemPath);
                
                if (stats.isDirectory()) {
                    this.logger.info(`Alt klas√∂r taranƒ±yor: ${itemPath}`);
                    // Alt klas√∂rleri de tara
                    const subFiles = this.scanHistoryFiles(itemPath);
                    historyFiles.push(...subFiles);
                } else if (item.endsWith('.m3u')) {
                    this.logger.info(`M3U dosyasƒ± bulundu: ${itemPath}`);
                    historyFiles.push({
                        filePath: itemPath,
                        fileName: item,
                        size: stats.size,
                        modified: stats.mtime
                    });
                }
            }
        } catch (error) {
            this.logger.error(`History klas√∂r tarama hatasƒ±: ${historyRoot}`, { error: error.message });
        }
        
        this.logger.info(`Toplam ${historyFiles.length} M3U dosyasƒ± bulundu`);
        return historyFiles;
    }

    /**
     * M3U dosyasƒ±ndan track'leri √ßƒ±kar
     * @param {string} filePath - M3U dosya yolu
     * @returns {Array} Track listesi
     */
    extractTracksFromFile(filePath) {
        const tracks = [];
        
        try {
            const content = fs.readFileSync(filePath, 'utf8');
            const lines = content.split('\n');
            
            for (const line of lines) {
                const trimmedLine = line.trim();
                
                // M3U dosyasƒ±nda # ile ba≈ülamayan satƒ±rlar dosya yolu
                if (trimmedLine && !trimmedLine.startsWith('#')) {
                    const fileName = path.basename(trimmedLine);
                    const fileNameOnly = path.parse(trimmedLine).name;
                    tracks.push({
                        path: trimmedLine,
                        normalizedFileName: this.normalizeFileName(fileNameOnly) // fileNameOnly'yi normalize et
                    });
                }
            }
        } catch (error) {
            this.logger.error(`M3U dosya okuma hatasƒ±: ${filePath}`, { error: error.message });
        }
        
        return tracks;
    }

    /**
     * Dosya adƒ±nƒ± normalize et
     * @param {string} fileName - Dosya adƒ±
     * @returns {string} Normalize edilmi≈ü ad
     */
    normalizeFileName(fileName) {
        const { normalizeFileName } = require('../../shared/utils');
        return normalizeFileName(fileName);
    }

    /**
     * Track'leri veritabanƒ±na ekle
     * @param {Array} tracks - Track listesi
     * @param {string} sourceFile - Kaynak dosya yolu
     */
    insertTracks(tracks, sourceFile) {
        try {
            const stmt = this.db.prepare(`
                INSERT INTO tracks (path, fileName, fileNameOnly, normalizedFileName, source, source_file, is_matched, created_at)
                VALUES (?, ?, ?, ?, 'history', ?, 0, ?)
            `);

            for (const track of tracks) {
                // fileName ve fileNameOnly olu≈ütur
                const fileName = path.basename(track.path);
                const fileNameOnly = path.parse(track.path).name;
                stmt.run(track.path, fileName, fileNameOnly, track.normalizedFileName, sourceFile, new Date().toISOString());
            }
        } catch (error) {
            this.logger.error(`Track ekleme hatasƒ±: ${error.message}`, { error: error.message });
        }
    }

    /**
     * Dosyanƒ±n daha √∂nce i≈ülenip i≈ülenmediƒüini kontrol et
     * @param {string} filePath - Dosya yolu
     * @returns {boolean}
     */
    isFileProcessed(filePath) {
        try {
            const stmt = this.db.prepare(`
                SELECT COUNT(*) as count FROM tracks 
                WHERE source = 'history' AND source_file = ?
            `);
            const result = stmt.get(filePath);
            return result.count > 0;
        } catch (error) {
            this.logger.error(`Dosya i≈ülenme kontrol√º hatasƒ±: ${error.message}`, { filePath });
            return false;
        }
    }

    /**
     * Otomatik track e≈üle≈ütirme
     * @returns {Object} E≈üle≈ütirme sonu√ßlarƒ±
     */
    async performAutoMatch() {
        try {
            this.logger.info('Otomatik track e≈üle≈ütirme ba≈ülatƒ±lƒ±yor...');

            // 1. A≈üama: Tam yol e≈üle≈ümesi (path = path)
            const exactMatches = this.performExactPathMatch();
            this.logger.info(`‚úÖ 1. A≈üama: ${exactMatches} track tam yol e≈üle≈ümesi ile e≈üle≈ütirildi`);

            // 2. A≈üama: Dosya adƒ± + uzantƒ± e≈üle≈ümesi (fileName = fileName)
            const filenameMatches = this.performFilenameMatch();
            this.logger.info(`‚úÖ 2. A≈üama: ${filenameMatches} track dosya adƒ± + uzantƒ± e≈üle≈ümesi ile e≈üle≈ütirildi`);

            // 3. A≈üama: Dosya adƒ± - uzantƒ± e≈üle≈ümesi (fileNameOnly = fileNameOnly)
            const filenameOnlyMatches = this.performFilenameOnlyMatch();
            this.logger.info(`‚úÖ 3. A≈üama: ${filenameOnlyMatches} track dosya adƒ± - uzantƒ± e≈üle≈ümesi ile e≈üle≈ütirildi`);

            // ƒ∞statistikler
            const stats = this.getMatchStats();

            const result = {
                success: true,
                data: {
                    exactMatches,
                    filenameMatches,
                    filenameOnlyMatches,
                    totalMatches: exactMatches + filenameMatches + filenameOnlyMatches,
                    stats
                },
                message: 'Otomatik e≈üle≈ütirme ba≈üarƒ±yla tamamlandƒ± (3 a≈üama)'
            };

            this.logger.info('Auto-match result:', result);
            return result;

        } catch (error) {
            this.logger.error('Otomatik e≈üle≈ütirme hatasƒ±:', error);
            return {
                success: false,
                message: 'Otomatik e≈üle≈ütirme hatasƒ±',
                error: error.message
            };
        }
    }

    /**
     * Tam yol e≈üle≈ümesi yap
     * @returns {number} E≈üle≈üen track sayƒ±sƒ±
     */
    performExactPathMatch() {
        const updateStmt = this.db.prepare(`
            UPDATE tracks 
            SET is_matched = 1, 
                matched_music_file_id = (
                    SELECT mf.id 
                    FROM music_files mf 
                    WHERE mf.path = tracks.path
                ),
                updated_at = CURRENT_TIMESTAMP
            WHERE tracks.path IN (
                SELECT mf.path 
                FROM music_files mf 
                WHERE mf.path = tracks.path
            ) AND tracks.is_matched = 0
        `);
        const result = updateStmt.run();
        return result.changes;
    }

    /**
     * Filename-only e≈üle≈ümesi yap
     * @returns {number} E≈üle≈üen track sayƒ±sƒ±
     */
    performFilenameMatch() {
        const updateStmt = this.db.prepare(`
            UPDATE tracks 
            SET is_matched = 1, 
                matched_music_file_id = (
                    SELECT mf.id 
                    FROM music_files mf 
                    WHERE mf.fileName = tracks.fileName
                    LIMIT 1
                ),
                updated_at = CURRENT_TIMESTAMP
            WHERE tracks.is_matched = 0 
            AND tracks.fileName IN (
                SELECT mf.fileName 
                FROM music_files mf 
                WHERE mf.fileName = tracks.fileName
            )
        `);
        const result = updateStmt.run();
        return result.changes;
    }

    /**
     * Dosya adƒ± - uzantƒ± e≈üle≈ümesi yap (fileNameOnly = fileNameOnly)
     * @returns {number} E≈üle≈üen track sayƒ±sƒ±
     */
    performFilenameOnlyMatch() {
        const updateStmt = this.db.prepare(`
            UPDATE tracks 
            SET is_matched = 1, 
                matched_music_file_id = (
                    SELECT mf.id 
                    FROM music_files mf 
                    WHERE mf.fileNameOnly = tracks.fileNameOnly
                    LIMIT 1
                ),
                updated_at = CURRENT_TIMESTAMP
            WHERE tracks.is_matched = 0 
            AND tracks.fileNameOnly IN (
                SELECT mf.fileNameOnly 
                FROM music_files mf 
                WHERE mf.fileNameOnly = tracks.fileNameOnly
            )
        `);
        const result = updateStmt.run();
        return result.changes;
    }

    /**
     * E≈üle≈ütirme istatistikleri
     * @returns {Object} ƒ∞statistikler
     */
    getMatchStats() {
        const totalTracks = this.db.prepare('SELECT COUNT(*) as count FROM tracks').get().count;
        const matchedTracks = this.db.prepare('SELECT COUNT(*) as count FROM tracks WHERE is_matched = 1').get().count;
        const unmatchedTracks = this.db.prepare('SELECT COUNT(*) as count FROM tracks WHERE is_matched = 0').get().count;
        const totalMusicFiles = this.db.prepare('SELECT COUNT(*) as count FROM music_files').get().count;

        return {
            totalTracks,
            matchedTracks,
            unmatchedTracks,
            totalMusicFiles,
            matchRate: totalTracks > 0 ? ((matchedTracks / totalTracks) * 100).toFixed(2) : 0
        };
    }

    /**
     * Test edilebilir kelime √ßƒ±kartmalƒ± arama
     * @param {string} searchQuery - Aranacak kelime
     * @param {number} threshold - Minimum benzerlik oranƒ± (0.0-1.0)
     * @param {number} limit - Maksimum sonu√ß sayƒ±sƒ±
     * @returns {Object} Arama sonucu
     */
    async performTestWordSimilaritySearch(searchQuery, threshold = 0.3, limit = 50) {
        try {
            this.logger.info(`Test kelime √ßƒ±kartmalƒ± arama ba≈ülatƒ±lƒ±yor: "${searchQuery}" (threshold: ${threshold}, limit: ${limit})`);

            // Shared utils'den WordSimilaritySearch sƒ±nƒ±fƒ±nƒ± kullan
            const wordSimilaritySearch = new WordSimilaritySearch(this.db);
            const result = await wordSimilaritySearch.performTestWordSimilaritySearch(searchQuery);

            return {
                success: true,
                data: result
            };

        } catch (error) {
            this.logger.error('Test kelime √ßƒ±kartmalƒ± arama hatasƒ±:', error);
            return {
                success: false,
                message: 'Test kelime √ßƒ±kartmalƒ± arama hatasƒ±',
                error: error.message
            };
        }
    }


    /**
     * History istatistikleri
     * @returns {Object} ƒ∞statistikler
     */
    getStats() {
        try {
            const totalTracks = this.db.prepare('SELECT COUNT(*) as count FROM tracks WHERE source = ?').get('history').count;
            const matchedTracks = this.db.prepare('SELECT COUNT(*) as count FROM tracks WHERE source = ? AND is_matched = 1').get('history').count;
            const unmatchedTracks = totalTracks - matchedTracks;

            return {
                success: true,
                data: {
                    totalTracks,
                    matchedTracks,
                    unmatchedTracks,
                    matchRate: totalTracks > 0 ? (matchedTracks / totalTracks * 100).toFixed(2) : 0
                }
            };
        } catch (error) {
            this.logger.error(`History istatistik hatasƒ±: ${error.message}`, { error: error.message });
            return {
                success: false,
                message: 'History istatistik hatasƒ±',
                error: error.message
            };
        }
    }
}

module.exports = new HistoryService();